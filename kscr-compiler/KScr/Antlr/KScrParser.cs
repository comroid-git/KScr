//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.10.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/dev/KScr/grammar\KScrParser.g4 by ANTLR 4.10.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace KScr.Antlr {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class KScrParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		PACKAGE=1, IMPORT=2, PUBLIC=3, INTERNAL=4, PROTECTED=5, PRIVATE=6, STATIC=7, 
		FINAL=8, ABSTRACT=9, NATIVE=10, SYNCHRONIZED=11, CLASS=12, INTERFACE=13, 
		ENUM=14, ANNOTATION=15, EXTENDS=16, IMPLEMENTS=17, RETURN=18, THROW=19, 
		NEW=20, YIELD=21, IS=22, MARK=23, JUMP=24, IF=25, ELSE=26, FOR=27, FOREACH=28, 
		DO=29, WHILE=30, SWITCH=31, CASE=32, DEFAULT=33, BREAK=34, CONTINUE=35, 
		TRY=36, CATCH=37, FINALLY=38, OBJECT=39, ARRAYIDENT=40, TUPLEIDENT=41, 
		TYPE=42, NUMIDENT=43, BYTE=44, SHORT=45, INT=46, LONG=47, FLOAT=48, DOUBLE=49, 
		VOID=50, VAR=51, NUMLIT=52, STRLIT=53, STDIOLIT=54, ENDLLIT=55, NULL=56, 
		TRUE=57, FALSE=58, THIS=59, SUPER=60, GET=61, SET=62, INIT=63, LPAREN=64, 
		RPAREN=65, LBRACE=66, RBRACE=67, LSQUAR=68, RSQUAR=69, COLON=70, SEMICOLON=71, 
		DOT=72, COMMA=73, EXCLAMATION=74, QUESTION=75, SHORTELIPSES=76, ELIPSES=77, 
		TILDE=78, ESCAPE_QUOTE=79, QUOTE=80, AND=81, OR=82, PLUSPLUS=83, MINUSMINUS=84, 
		BITAND=85, BITOR=86, UP=87, STAR=88, SLASH=89, PLUS=90, MINUS=91, PERCENT=92, 
		AT=93, LSHIFT=94, RSHIFT=95, ULSHIFT=96, URSHIFT=97, EQUAL=98, INEQUAL=99, 
		GREATEREQ=100, LESSEREQ=101, GREATER=102, LESSER=103, ASSIGN=104, REQARROW=105, 
		LDASHARROW=106, RDASHARROW=107, LLDASHARROW=108, RRDASHARROW=109, RREQARROW=110, 
		ID=111, DIGIT=112, LETTER=113, SING_COMMENT=114, WS=115, UNMATCHED=116;
	public const int
		RULE_packageDecl = 0, RULE_imports = 1, RULE_importDecl = 2, RULE_annotationArg = 3, 
		RULE_annotation = 4, RULE_modifier = 5, RULE_modifiers = 6, RULE_classType = 7, 
		RULE_genericTypeUses = 8, RULE_type = 9, RULE_rawType = 10, RULE_genericTypeDef = 11, 
		RULE_genericTypeDefs = 12, RULE_objectExtends = 13, RULE_objectImplements = 14, 
		RULE_parameter = 15, RULE_parameters = 16, RULE_arguments = 17, RULE_statements = 18, 
		RULE_noBlock = 19, RULE_uniformBlock = 20, RULE_normalBlock = 21, RULE_memberExpr = 22, 
		RULE_lambdaBlock = 23, RULE_caseBlock = 24, RULE_memberBlock = 25, RULE_codeBlock = 26, 
		RULE_initDecl = 27, RULE_subConstructorCall = 28, RULE_subConstructorCalls = 29, 
		RULE_constructorDecl = 30, RULE_methodDecl = 31, RULE_indexerMemberDecl = 32, 
		RULE_propGetter = 33, RULE_propSetter = 34, RULE_propInit = 35, RULE_propBlock = 36, 
		RULE_propertyDecl = 37, RULE_member = 38, RULE_classDecl = 39, RULE_file = 40, 
		RULE_inferType = 41, RULE_indexerEmpty = 42, RULE_indexerDecl = 43, RULE_indexerExpr = 44, 
		RULE_cast = 45, RULE_declaration = 46, RULE_mutation = 47, RULE_call = 48, 
		RULE_ctorCall = 49, RULE_newArray = 50, RULE_newListedArray = 51, RULE_label = 52, 
		RULE_lambda = 53, RULE_returnStatement = 54, RULE_throwStatement = 55, 
		RULE_markStatement = 56, RULE_jumpStatement = 57, RULE_tryCatchStatement = 58, 
		RULE_tryWithResourcesStatement = 59, RULE_catchBlocks = 60, RULE_catchBlock = 61, 
		RULE_finallyBlock = 62, RULE_ifStatement = 63, RULE_elseStatement = 64, 
		RULE_whileStatement = 65, RULE_forStatement = 66, RULE_foreachStatement = 67, 
		RULE_doWhile = 68, RULE_switchStatement = 69, RULE_caseClause = 70, RULE_defaultClause = 71, 
		RULE_statement = 72, RULE_typedExpr = 73, RULE_expr = 74, RULE_tupleDeclType = 75, 
		RULE_tupleDecl = 76, RULE_tupleExpr = 77, RULE_binaryop = 78, RULE_binaryop_late = 79, 
		RULE_prefixop = 80, RULE_postfixop = 81, RULE_id = 82, RULE_idPart = 83, 
		RULE_array = 84, RULE_tuple = 85, RULE_num = 86, RULE_primitiveTypeLit = 87, 
		RULE_primitiveLit = 88;
	public static readonly string[] ruleNames = {
		"packageDecl", "imports", "importDecl", "annotationArg", "annotation", 
		"modifier", "modifiers", "classType", "genericTypeUses", "type", "rawType", 
		"genericTypeDef", "genericTypeDefs", "objectExtends", "objectImplements", 
		"parameter", "parameters", "arguments", "statements", "noBlock", "uniformBlock", 
		"normalBlock", "memberExpr", "lambdaBlock", "caseBlock", "memberBlock", 
		"codeBlock", "initDecl", "subConstructorCall", "subConstructorCalls", 
		"constructorDecl", "methodDecl", "indexerMemberDecl", "propGetter", "propSetter", 
		"propInit", "propBlock", "propertyDecl", "member", "classDecl", "file", 
		"inferType", "indexerEmpty", "indexerDecl", "indexerExpr", "cast", "declaration", 
		"mutation", "call", "ctorCall", "newArray", "newListedArray", "label", 
		"lambda", "returnStatement", "throwStatement", "markStatement", "jumpStatement", 
		"tryCatchStatement", "tryWithResourcesStatement", "catchBlocks", "catchBlock", 
		"finallyBlock", "ifStatement", "elseStatement", "whileStatement", "forStatement", 
		"foreachStatement", "doWhile", "switchStatement", "caseClause", "defaultClause", 
		"statement", "typedExpr", "expr", "tupleDeclType", "tupleDecl", "tupleExpr", 
		"binaryop", "binaryop_late", "prefixop", "postfixop", "id", "idPart", 
		"array", "tuple", "num", "primitiveTypeLit", "primitiveLit"
	};

	private static readonly string[] _LiteralNames = {
		null, "'package'", "'import'", "'public'", "'internal'", "'protected'", 
		"'private'", "'static'", "'final'", "'abstract'", "'native'", "'synchronized'", 
		"'class'", "'interface'", "'enum'", "'annotation'", "'extends'", "'implements'", 
		"'return'", "'throw'", "'new'", "'yield'", "'is'", "'mark'", "'jump'", 
		"'if'", "'else'", "'for'", "'foreach'", "'do'", "'while'", "'switch'", 
		"'case'", "'default'", "'break'", "'continue'", "'try'", "'catch'", "'finally'", 
		"'object'", "'array'", "'tuple'", "'type'", "'num'", "'byte'", "'short'", 
		"'int'", "'long'", "'float'", "'double'", "'void'", "'var'", null, null, 
		"'stdio'", "'endl'", "'null'", "'true'", "'false'", "'this'", "'super'", 
		"'get'", "'set'", "'init'", "'('", "')'", "'{'", "'}'", "'['", "']'", 
		"':'", "';'", "'.'", "','", "'!'", "'?'", "'..'", "'...'", "'~'", "'\\\"'", 
		"'\"'", "'&&'", "'||'", "'++'", "'--'", "'&'", "'|'", "'^'", "'*'", "'/'", 
		"'+'", "'-'", "'%'", "'@'", "'<<'", "'>>'", "'<<<'", "'>>>'", "'=='", 
		"'!='", "'>='", "'<='", "'>'", "'<'", "'='", "'=>'", "'<-'", "'->'", "'<<-'", 
		"'->>'", "'=>>'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "PACKAGE", "IMPORT", "PUBLIC", "INTERNAL", "PROTECTED", "PRIVATE", 
		"STATIC", "FINAL", "ABSTRACT", "NATIVE", "SYNCHRONIZED", "CLASS", "INTERFACE", 
		"ENUM", "ANNOTATION", "EXTENDS", "IMPLEMENTS", "RETURN", "THROW", "NEW", 
		"YIELD", "IS", "MARK", "JUMP", "IF", "ELSE", "FOR", "FOREACH", "DO", "WHILE", 
		"SWITCH", "CASE", "DEFAULT", "BREAK", "CONTINUE", "TRY", "CATCH", "FINALLY", 
		"OBJECT", "ARRAYIDENT", "TUPLEIDENT", "TYPE", "NUMIDENT", "BYTE", "SHORT", 
		"INT", "LONG", "FLOAT", "DOUBLE", "VOID", "VAR", "NUMLIT", "STRLIT", "STDIOLIT", 
		"ENDLLIT", "NULL", "TRUE", "FALSE", "THIS", "SUPER", "GET", "SET", "INIT", 
		"LPAREN", "RPAREN", "LBRACE", "RBRACE", "LSQUAR", "RSQUAR", "COLON", "SEMICOLON", 
		"DOT", "COMMA", "EXCLAMATION", "QUESTION", "SHORTELIPSES", "ELIPSES", 
		"TILDE", "ESCAPE_QUOTE", "QUOTE", "AND", "OR", "PLUSPLUS", "MINUSMINUS", 
		"BITAND", "BITOR", "UP", "STAR", "SLASH", "PLUS", "MINUS", "PERCENT", 
		"AT", "LSHIFT", "RSHIFT", "ULSHIFT", "URSHIFT", "EQUAL", "INEQUAL", "GREATEREQ", 
		"LESSEREQ", "GREATER", "LESSER", "ASSIGN", "REQARROW", "LDASHARROW", "RDASHARROW", 
		"LLDASHARROW", "RRDASHARROW", "RREQARROW", "ID", "DIGIT", "LETTER", "SING_COMMENT", 
		"WS", "UNMATCHED"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "KScrParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static KScrParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public KScrParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public KScrParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class PackageDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PACKAGE() { return GetToken(KScrParser.PACKAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public PackageDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_packageDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPackageDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPackageDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackageDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PackageDeclContext packageDecl() {
		PackageDeclContext _localctx = new PackageDeclContext(Context, State);
		EnterRule(_localctx, 0, RULE_packageDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 178;
			Match(PACKAGE);
			State = 179;
			id();
			State = 180;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ImportDeclContext[] importDecl() {
			return GetRuleContexts<ImportDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportDeclContext importDecl(int i) {
			return GetRuleContext<ImportDeclContext>(i);
		}
		public ImportsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_imports; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterImports(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitImports(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImports(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportsContext imports() {
		ImportsContext _localctx = new ImportsContext(Context, State);
		EnterRule(_localctx, 2, RULE_imports);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 185;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==IMPORT) {
				{
				{
				State = 182;
				importDecl();
				}
				}
				State = 187;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPORT() { return GetToken(KScrParser.IMPORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(KScrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(KScrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(KScrParser.STAR, 0); }
		public ImportDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterImportDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitImportDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportDeclContext importDecl() {
		ImportDeclContext _localctx = new ImportDeclContext(Context, State);
		EnterRule(_localctx, 4, RULE_importDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188;
			Match(IMPORT);
			State = 190;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STATIC) {
				{
				State = 189;
				Match(STATIC);
				}
			}

			State = 192;
			id();
			State = 195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DOT) {
				{
				State = 193;
				Match(DOT);
				State = 194;
				Match(STAR);
				}
			}

			State = 197;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnnotationArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public AnnotationArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_annotationArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterAnnotationArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitAnnotationArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnnotationArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnnotationArgContext annotationArg() {
		AnnotationArgContext _localctx = new AnnotationArgContext(Context, State);
		EnterRule(_localctx, 6, RULE_annotationArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199;
			idPart();
			State = 200;
			Match(ASSIGN);
			State = 201;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnnotationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(KScrParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationArgContext[] annotationArg() {
			return GetRuleContexts<AnnotationArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationArgContext annotationArg(int i) {
			return GetRuleContext<AnnotationArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public AnnotationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_annotation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterAnnotation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitAnnotation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnnotationContext annotation() {
		AnnotationContext _localctx = new AnnotationContext(Context, State);
		EnterRule(_localctx, 8, RULE_annotation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 203;
			Match(AT);
			State = 204;
			id();
			State = 218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 205;
				Match(LPAREN);
				State = 215;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
				case 1:
					{
					State = 206;
					annotationArg();
					State = 211;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 207;
						Match(COMMA);
						State = 208;
						annotationArg();
						}
						}
						State = 213;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
					break;
				case 2:
					{
					State = 214;
					expr(0);
					}
					break;
				}
				State = 217;
				Match(RPAREN);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifierContext : ParserRuleContext {
		public ModifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifier; } }
	 
		public ModifierContext() { }
		public virtual void CopyFrom(ModifierContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ModFinalContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(KScrParser.FINAL, 0); }
		public ModFinalContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModFinal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModFinal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModFinal(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModPrivateContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVATE() { return GetToken(KScrParser.PRIVATE, 0); }
		public ModPrivateContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModPrivate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModPrivate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModPrivate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModInternalContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERNAL() { return GetToken(KScrParser.INTERNAL, 0); }
		public ModInternalContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModInternal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModInternal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModInternal(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModAbstractContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ABSTRACT() { return GetToken(KScrParser.ABSTRACT, 0); }
		public ModAbstractContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModAbstract(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModAbstract(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModAbstract(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModProtectedContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROTECTED() { return GetToken(KScrParser.PROTECTED, 0); }
		public ModProtectedContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModProtected(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModProtected(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModProtected(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModNativeContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NATIVE() { return GetToken(KScrParser.NATIVE, 0); }
		public ModNativeContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModNative(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModNative(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModNative(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModStaticContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(KScrParser.STATIC, 0); }
		public ModStaticContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModStatic(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModStatic(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModStatic(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModPublicContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUBLIC() { return GetToken(KScrParser.PUBLIC, 0); }
		public ModPublicContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModPublic(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModPublic(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModPublic(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ModSyncronizedContext : ModifierContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SYNCHRONIZED() { return GetToken(KScrParser.SYNCHRONIZED, 0); }
		public ModSyncronizedContext(ModifierContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModSyncronized(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModSyncronized(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModSyncronized(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModifierContext modifier() {
		ModifierContext _localctx = new ModifierContext(Context, State);
		EnterRule(_localctx, 10, RULE_modifier);
		try {
			State = 229;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PUBLIC:
				_localctx = new ModPublicContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 220;
				Match(PUBLIC);
				}
				break;
			case INTERNAL:
				_localctx = new ModInternalContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 221;
				Match(INTERNAL);
				}
				break;
			case PROTECTED:
				_localctx = new ModProtectedContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 222;
				Match(PROTECTED);
				}
				break;
			case PRIVATE:
				_localctx = new ModPrivateContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 223;
				Match(PRIVATE);
				}
				break;
			case STATIC:
				_localctx = new ModStaticContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 224;
				Match(STATIC);
				}
				break;
			case FINAL:
				_localctx = new ModFinalContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 225;
				Match(FINAL);
				}
				break;
			case ABSTRACT:
				_localctx = new ModAbstractContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 226;
				Match(ABSTRACT);
				}
				break;
			case SYNCHRONIZED:
				_localctx = new ModSyncronizedContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 227;
				Match(SYNCHRONIZED);
				}
				break;
			case NATIVE:
				_localctx = new ModNativeContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 228;
				Match(NATIVE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModifiersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifierContext[] modifier() {
			return GetRuleContexts<ModifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModifierContext modifier(int i) {
			return GetRuleContext<ModifierContext>(i);
		}
		public ModifiersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifiers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterModifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitModifiers(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModifiers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModifiersContext modifiers() {
		ModifiersContext _localctx = new ModifiersContext(Context, State);
		EnterRule(_localctx, 12, RULE_modifiers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 234;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PUBLIC) | (1L << INTERNAL) | (1L << PROTECTED) | (1L << PRIVATE) | (1L << STATIC) | (1L << FINAL) | (1L << ABSTRACT) | (1L << NATIVE) | (1L << SYNCHRONIZED))) != 0)) {
				{
				{
				State = 231;
				modifier();
				}
				}
				State = 236;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassTypeContext : ParserRuleContext {
		public ClassTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_classType; } }
	 
		public ClassTypeContext() { }
		public virtual void CopyFrom(ClassTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CtEnumContext : ClassTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENUM() { return GetToken(KScrParser.ENUM, 0); }
		public CtEnumContext(ClassTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCtEnum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCtEnum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtEnum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CtAnnotationContext : ClassTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANNOTATION() { return GetToken(KScrParser.ANNOTATION, 0); }
		public CtAnnotationContext(ClassTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCtAnnotation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCtAnnotation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtAnnotation(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CtInterfaceContext : ClassTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTERFACE() { return GetToken(KScrParser.INTERFACE, 0); }
		public CtInterfaceContext(ClassTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCtInterface(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCtInterface(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtInterface(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CtClassContext : ClassTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASS() { return GetToken(KScrParser.CLASS, 0); }
		public CtClassContext(ClassTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCtClass(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCtClass(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtClass(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClassTypeContext classType() {
		ClassTypeContext _localctx = new ClassTypeContext(Context, State);
		EnterRule(_localctx, 14, RULE_classType);
		try {
			State = 241;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CLASS:
				_localctx = new CtClassContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 237;
				Match(CLASS);
				}
				break;
			case INTERFACE:
				_localctx = new CtInterfaceContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 238;
				Match(INTERFACE);
				}
				break;
			case ENUM:
				_localctx = new CtEnumContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 239;
				Match(ENUM);
				}
				break;
			case ANNOTATION:
				_localctx = new CtAnnotationContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 240;
				Match(ANNOTATION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericTypeUsesContext : ParserRuleContext {
		public IToken n;
		public TypeContext first;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESSER() { return GetToken(KScrParser.LESSER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(KScrParser.GREATER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMLIT() { return GetToken(KScrParser.NUMLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public GenericTypeUsesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericTypeUses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterGenericTypeUses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitGenericTypeUses(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGenericTypeUses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GenericTypeUsesContext genericTypeUses() {
		GenericTypeUsesContext _localctx = new GenericTypeUsesContext(Context, State);
		EnterRule(_localctx, 16, RULE_genericTypeUses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 243;
			Match(LESSER);
			State = 246;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NUMLIT:
				{
				State = 244;
				_localctx.n = Match(NUMLIT);
				}
				break;
			case ENUM:
			case ANNOTATION:
			case OBJECT:
			case ARRAYIDENT:
			case TUPLEIDENT:
			case TYPE:
			case NUMIDENT:
			case BYTE:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
			case VOID:
			case ID:
				{
				State = 245;
				_localctx.first = type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 252;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 248;
				Match(COMMA);
				State = 249;
				type();
				}
				}
				State = 254;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 255;
			Match(GREATER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
	 
		public TypeContext() { }
		public virtual void CopyFrom(TypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ArrayTypeUseContext : TypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public RawTypeContext rawType() {
			return GetRuleContext<RawTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeUsesContext genericTypeUses() {
			return GetRuleContext<GenericTypeUsesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexerEmptyContext indexerEmpty() {
			return GetRuleContext<IndexerEmptyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELIPSES() { return GetToken(KScrParser.ELIPSES, 0); }
		public ArrayTypeUseContext(TypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterArrayTypeUse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitArrayTypeUse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayTypeUse(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ImportedTypeNameContext : TypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		public ImportedTypeNameContext(TypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterImportedTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitImportedTypeName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportedTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NormalTypeUseContext : TypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public RawTypeContext rawType() {
			return GetRuleContext<RawTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeUsesContext genericTypeUses() {
			return GetRuleContext<GenericTypeUsesContext>(0);
		}
		public NormalTypeUseContext(TypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNormalTypeUse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNormalTypeUse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalTypeUse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 18, RULE_type);
		try {
			State = 270;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				_localctx = new ImportedTypeNameContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 257;
				idPart();
				}
				break;
			case 2:
				_localctx = new NormalTypeUseContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 258;
				rawType();
				State = 260;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
				case 1:
					{
					State = 259;
					genericTypeUses();
					}
					break;
				}
				}
				break;
			case 3:
				_localctx = new ArrayTypeUseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 262;
				rawType();
				State = 264;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
				case 1:
					{
					State = 263;
					genericTypeUses();
					}
					break;
				}
				State = 268;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
				case 1:
					{
					State = 266;
					indexerEmpty();
					}
					break;
				case 2:
					{
					State = 267;
					Match(ELIPSES);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RawTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimitiveTypeLitContext primitiveTypeLit() {
			return GetRuleContext<PrimitiveTypeLitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public RawTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rawType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterRawType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitRawType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRawType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RawTypeContext rawType() {
		RawTypeContext _localctx = new RawTypeContext(Context, State);
		EnterRule(_localctx, 20, RULE_rawType);
		try {
			State = 274;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENUM:
			case OBJECT:
			case ARRAYIDENT:
			case TUPLEIDENT:
			case TYPE:
			case NUMIDENT:
			case BYTE:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
			case VOID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 272;
				primitiveTypeLit();
				}
				break;
			case ANNOTATION:
			case ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 273;
				id();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericTypeDefContext : ParserRuleContext {
		public IToken elp;
		public TypeContext ext;
		public TypeContext sup;
		public IToken defN;
		public TypeContext def;
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDS() { return GetToken(KScrParser.EXTENDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPER() { return GetToken(KScrParser.SUPER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELIPSES() { return GetToken(KScrParser.ELIPSES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMLIT() { return GetToken(KScrParser.NUMLIT, 0); }
		public GenericTypeDefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericTypeDef; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterGenericTypeDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitGenericTypeDef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGenericTypeDef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GenericTypeDefContext genericTypeDef() {
		GenericTypeDefContext _localctx = new GenericTypeDefContext(Context, State);
		EnterRule(_localctx, 22, RULE_genericTypeDef);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 276;
			idPart();
			State = 278;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELIPSES) {
				{
				State = 277;
				_localctx.elp = Match(ELIPSES);
				}
			}

			State = 284;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXTENDS:
				{
				State = 280;
				Match(EXTENDS);
				State = 281;
				_localctx.ext = type();
				}
				break;
			case SUPER:
				{
				State = 282;
				Match(SUPER);
				State = 283;
				_localctx.sup = type();
				}
				break;
			case COMMA:
			case GREATER:
			case ASSIGN:
				break;
			default:
				break;
			}
			State = 291;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASSIGN) {
				{
				State = 286;
				Match(ASSIGN);
				State = 289;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case NUMLIT:
					{
					State = 287;
					_localctx.defN = Match(NUMLIT);
					}
					break;
				case ENUM:
				case ANNOTATION:
				case OBJECT:
				case ARRAYIDENT:
				case TUPLEIDENT:
				case TYPE:
				case NUMIDENT:
				case BYTE:
				case SHORT:
				case INT:
				case LONG:
				case FLOAT:
				case DOUBLE:
				case VOID:
				case ID:
					{
					State = 288;
					_localctx.def = type();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GenericTypeDefsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESSER() { return GetToken(KScrParser.LESSER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(KScrParser.GREATER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMLIT() { return GetToken(KScrParser.NUMLIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeDefContext[] genericTypeDef() {
			return GetRuleContexts<GenericTypeDefContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeDefContext genericTypeDef(int i) {
			return GetRuleContext<GenericTypeDefContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public GenericTypeDefsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericTypeDefs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterGenericTypeDefs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitGenericTypeDefs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGenericTypeDefs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GenericTypeDefsContext genericTypeDefs() {
		GenericTypeDefsContext _localctx = new GenericTypeDefsContext(Context, State);
		EnterRule(_localctx, 24, RULE_genericTypeDefs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 293;
			Match(LESSER);
			State = 296;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NUMLIT:
				{
				State = 294;
				Match(NUMLIT);
				}
				break;
			case ANNOTATION:
			case ID:
				{
				State = 295;
				genericTypeDef();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 302;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 298;
				Match(COMMA);
				State = 299;
				genericTypeDef();
				}
				}
				State = 304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 305;
			Match(GREATER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectExtendsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDS() { return GetToken(KScrParser.EXTENDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public ObjectExtendsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectExtends; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterObjectExtends(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitObjectExtends(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectExtends(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectExtendsContext objectExtends() {
		ObjectExtendsContext _localctx = new ObjectExtendsContext(Context, State);
		EnterRule(_localctx, 26, RULE_objectExtends);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 307;
			Match(EXTENDS);
			State = 308;
			type();
			State = 313;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 309;
				Match(COMMA);
				State = 310;
				type();
				}
				}
				State = 315;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectImplementsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPLEMENTS() { return GetToken(KScrParser.IMPLEMENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public ObjectImplementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectImplements; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterObjectImplements(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitObjectImplements(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectImplements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectImplementsContext objectImplements() {
		ObjectImplementsContext _localctx = new ObjectImplementsContext(Context, State);
		EnterRule(_localctx, 28, RULE_objectImplements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 316;
			Match(IMPLEMENTS);
			State = 317;
			type();
			State = 322;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 318;
				Match(COMMA);
				State = 319;
				type();
				}
				}
				State = 324;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINAL() { return GetToken(KScrParser.FINAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(Context, State);
		EnterRule(_localctx, 30, RULE_parameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FINAL) {
				{
				State = 325;
				Match(FINAL);
				}
			}

			State = 328;
			type();
			State = 329;
			idPart();
			State = 332;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ASSIGN) {
				{
				State = 330;
				Match(ASSIGN);
				State = 331;
				expr(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public ParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitParameters(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParametersContext parameters() {
		ParametersContext _localctx = new ParametersContext(Context, State);
		EnterRule(_localctx, 32, RULE_parameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 334;
			Match(LPAREN);
			State = 343;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << FINAL) | (1L << ENUM) | (1L << ANNOTATION) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID))) != 0) || _la==ID) {
				{
				State = 335;
				parameter();
				State = 340;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 336;
					Match(COMMA);
					State = 337;
					parameter();
					}
					}
					State = 342;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 345;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 34, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 347;
			Match(LPAREN);
			State = 356;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ENUM) | (1L << ANNOTATION) | (1L << THROW) | (1L << NEW) | (1L << YIELD) | (1L << SWITCH) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID) | (1L << NUMLIT) | (1L << STRLIT) | (1L << STDIOLIT) | (1L << ENDLLIT) | (1L << NULL) | (1L << TRUE) | (1L << FALSE) | (1L << THIS) | (1L << SUPER))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (LPAREN - 64)) | (1L << (EXCLAMATION - 64)) | (1L << (PLUSPLUS - 64)) | (1L << (MINUSMINUS - 64)) | (1L << (MINUS - 64)) | (1L << (ID - 64)))) != 0)) {
				{
				State = 348;
				expr(0);
				State = 353;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 349;
					Match(COMMA);
					State = 350;
					expr(0);
					}
					}
					State = 355;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 358;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(Context, State);
		EnterRule(_localctx, 36, RULE_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 363;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ENUM) | (1L << ANNOTATION) | (1L << RETURN) | (1L << THROW) | (1L << NEW) | (1L << YIELD) | (1L << MARK) | (1L << JUMP) | (1L << IF) | (1L << FOR) | (1L << FOREACH) | (1L << DO) | (1L << WHILE) | (1L << SWITCH) | (1L << TRY) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID) | (1L << NUMLIT) | (1L << STRLIT) | (1L << STDIOLIT) | (1L << ENDLLIT) | (1L << NULL) | (1L << TRUE) | (1L << FALSE) | (1L << THIS) | (1L << SUPER))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (LPAREN - 64)) | (1L << (SEMICOLON - 64)) | (1L << (EXCLAMATION - 64)) | (1L << (PLUSPLUS - 64)) | (1L << (MINUSMINUS - 64)) | (1L << (MINUS - 64)) | (1L << (ID - 64)))) != 0)) {
				{
				{
				State = 360;
				statement();
				}
				}
				State = 365;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NoBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public NoBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_noBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNoBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NoBlockContext noBlock() {
		NoBlockContext _localctx = new NoBlockContext(Context, State);
		EnterRule(_localctx, 38, RULE_noBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 366;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UniformBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public UniformBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uniformBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterUniformBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitUniformBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUniformBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UniformBlockContext uniformBlock() {
		UniformBlockContext _localctx = new UniformBlockContext(Context, State);
		EnterRule(_localctx, 40, RULE_uniformBlock);
		try {
			State = 370;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 368;
				expr(0);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 369;
				statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(KScrParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(KScrParser.RBRACE, 0); }
		public NormalBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NormalBlockContext normalBlock() {
		NormalBlockContext _localctx = new NormalBlockContext(Context, State);
		EnterRule(_localctx, 42, RULE_normalBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 372;
			Match(LBRACE);
			State = 373;
			statements();
			State = 374;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQARROW() { return GetToken(KScrParser.REQARROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UniformBlockContext uniformBlock() {
			return GetRuleContext<UniformBlockContext>(0);
		}
		public MemberExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemberExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemberExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberExprContext memberExpr() {
		MemberExprContext _localctx = new MemberExprContext(Context, State);
		EnterRule(_localctx, 44, RULE_memberExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 376;
			Match(REQARROW);
			State = 377;
			uniformBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LambdaBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RDASHARROW() { return GetToken(KScrParser.RDASHARROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UniformBlockContext uniformBlock() {
			return GetRuleContext<UniformBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalBlockContext normalBlock() {
			return GetRuleContext<NormalBlockContext>(0);
		}
		public LambdaBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lambdaBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterLambdaBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitLambdaBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLambdaBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LambdaBlockContext lambdaBlock() {
		LambdaBlockContext _localctx = new LambdaBlockContext(Context, State);
		EnterRule(_localctx, 46, RULE_lambdaBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 379;
			Match(RDASHARROW);
			State = 382;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ENUM:
			case ANNOTATION:
			case RETURN:
			case THROW:
			case NEW:
			case YIELD:
			case MARK:
			case JUMP:
			case IF:
			case FOR:
			case FOREACH:
			case DO:
			case WHILE:
			case SWITCH:
			case TRY:
			case OBJECT:
			case ARRAYIDENT:
			case TUPLEIDENT:
			case TYPE:
			case NUMIDENT:
			case BYTE:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
			case VOID:
			case NUMLIT:
			case STRLIT:
			case STDIOLIT:
			case ENDLLIT:
			case NULL:
			case TRUE:
			case FALSE:
			case THIS:
			case SUPER:
			case LPAREN:
			case SEMICOLON:
			case EXCLAMATION:
			case PLUSPLUS:
			case MINUSMINUS:
			case MINUS:
			case ID:
				{
				State = 380;
				uniformBlock();
				}
				break;
			case LBRACE:
				{
				State = 381;
				normalBlock();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseBlockContext : ParserRuleContext {
		public CaseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseBlock; } }
	 
		public CaseBlockContext() { }
		public virtual void CopyFrom(CaseBlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CaseStmtBlockContext : CaseBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(KScrParser.BREAK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public CaseStmtBlockContext(CaseBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCaseStmtBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCaseStmtBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseStmtBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CaseExprBlockContext : CaseBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberExprContext memberExpr() {
			return GetRuleContext<MemberExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(KScrParser.COMMA, 0); }
		public CaseExprBlockContext(CaseBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCaseExprBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCaseExprBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseExprBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseBlockContext caseBlock() {
		CaseBlockContext _localctx = new CaseBlockContext(Context, State);
		EnterRule(_localctx, 48, RULE_caseBlock);
		try {
			State = 392;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case COLON:
				_localctx = new CaseStmtBlockContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 384;
				Match(COLON);
				State = 385;
				statements();
				State = 386;
				Match(BREAK);
				State = 387;
				Match(SEMICOLON);
				}
				break;
			case REQARROW:
				_localctx = new CaseExprBlockContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 389;
				memberExpr();
				State = 390;
				Match(COMMA);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberBlockContext : ParserRuleContext {
		public MemberBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_memberBlock; } }
	 
		public MemberBlockContext() { }
		public virtual void CopyFrom(MemberBlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MemberNormalBlockContext : MemberBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public NormalBlockContext normalBlock() {
			return GetRuleContext<NormalBlockContext>(0);
		}
		public MemberNormalBlockContext(MemberBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemberNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemberNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberNormalBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberExprBlockContext : MemberBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberExprContext memberExpr() {
			return GetRuleContext<MemberExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public MemberExprBlockContext(MemberBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemberExprBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemberExprBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberExprBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberNoBlockContext : MemberBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public NoBlockContext noBlock() {
			return GetRuleContext<NoBlockContext>(0);
		}
		public MemberNoBlockContext(MemberBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemberNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemberNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberNoBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberBlockContext memberBlock() {
		MemberBlockContext _localctx = new MemberBlockContext(Context, State);
		EnterRule(_localctx, 50, RULE_memberBlock);
		try {
			State = 399;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LBRACE:
				_localctx = new MemberNormalBlockContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 394;
				normalBlock();
				}
				break;
			case REQARROW:
				_localctx = new MemberExprBlockContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 395;
				memberExpr();
				State = 396;
				Match(SEMICOLON);
				}
				break;
			case SEMICOLON:
				_localctx = new MemberNoBlockContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 398;
				noBlock();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CodeBlockContext : ParserRuleContext {
		public CodeBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codeBlock; } }
	 
		public CodeBlockContext() { }
		public virtual void CopyFrom(CodeBlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CodeStmtBlockContext : CodeBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public CodeStmtBlockContext(CodeBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCodeStmtBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCodeStmtBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodeStmtBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CodeNormalBlockContext : CodeBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public NormalBlockContext normalBlock() {
			return GetRuleContext<NormalBlockContext>(0);
		}
		public CodeNormalBlockContext(CodeBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCodeNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCodeNormalBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodeNormalBlock(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CodeNoBlockContext : CodeBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public NoBlockContext noBlock() {
			return GetRuleContext<NoBlockContext>(0);
		}
		public CodeNoBlockContext(CodeBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCodeNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCodeNoBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodeNoBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CodeBlockContext codeBlock() {
		CodeBlockContext _localctx = new CodeBlockContext(Context, State);
		EnterRule(_localctx, 52, RULE_codeBlock);
		try {
			State = 404;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
			case 1:
				_localctx = new CodeNormalBlockContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 401;
				normalBlock();
				}
				break;
			case 2:
				_localctx = new CodeStmtBlockContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 402;
				statement();
				}
				break;
			case 3:
				_localctx = new CodeNoBlockContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 403;
				noBlock();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InitDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATIC() { return GetToken(KScrParser.STATIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		public InitDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_initDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterInitDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitInitDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInitDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InitDeclContext initDecl() {
		InitDeclContext _localctx = new InitDeclContext(Context, State);
		EnterRule(_localctx, 54, RULE_initDecl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 406;
			Match(STATIC);
			State = 407;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubConstructorCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public SubConstructorCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subConstructorCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterSubConstructorCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitSubConstructorCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubConstructorCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubConstructorCallContext subConstructorCall() {
		SubConstructorCallContext _localctx = new SubConstructorCallContext(Context, State);
		EnterRule(_localctx, 56, RULE_subConstructorCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 409;
			type();
			State = 410;
			arguments();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubConstructorCallsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubConstructorCallContext[] subConstructorCall() {
			return GetRuleContexts<SubConstructorCallContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubConstructorCallContext subConstructorCall(int i) {
			return GetRuleContext<SubConstructorCallContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public SubConstructorCallsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subConstructorCalls; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterSubConstructorCalls(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitSubConstructorCalls(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubConstructorCalls(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubConstructorCallsContext subConstructorCalls() {
		SubConstructorCallsContext _localctx = new SubConstructorCallsContext(Context, State);
		EnterRule(_localctx, 58, RULE_subConstructorCalls);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 412;
			Match(COLON);
			State = 413;
			subConstructorCall();
			State = 418;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 414;
					Match(COMMA);
					State = 415;
					subConstructorCall();
					}
					} 
				}
				State = 420;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstructorDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifiersContext modifiers() {
			return GetRuleContext<ModifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext[] annotation() {
			return GetRuleContexts<AnnotationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext annotation(int i) {
			return GetRuleContext<AnnotationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubConstructorCallsContext subConstructorCalls() {
			return GetRuleContext<SubConstructorCallsContext>(0);
		}
		public ConstructorDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructorDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterConstructorDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitConstructorDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructorDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstructorDeclContext constructorDecl() {
		ConstructorDeclContext _localctx = new ConstructorDeclContext(Context, State);
		EnterRule(_localctx, 60, RULE_constructorDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 424;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AT) {
				{
				{
				State = 421;
				annotation();
				}
				}
				State = 426;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 427;
			modifiers();
			State = 428;
			type();
			State = 429;
			parameters();
			State = 431;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 430;
				subConstructorCalls();
				}
			}

			State = 433;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MethodDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifiersContext modifiers() {
			return GetRuleContext<ModifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParametersContext parameters() {
			return GetRuleContext<ParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext[] annotation() {
			return GetRuleContexts<AnnotationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext annotation(int i) {
			return GetRuleContext<AnnotationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeDefsContext genericTypeDefs() {
			return GetRuleContext<GenericTypeDefsContext>(0);
		}
		public MethodDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_methodDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMethodDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMethodDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MethodDeclContext methodDecl() {
		MethodDeclContext _localctx = new MethodDeclContext(Context, State);
		EnterRule(_localctx, 62, RULE_methodDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 438;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AT) {
				{
				{
				State = 435;
				annotation();
				}
				}
				State = 440;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 441;
			modifiers();
			State = 443;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESSER) {
				{
				State = 442;
				genericTypeDefs();
				}
			}

			State = 445;
			type();
			State = 446;
			idPart();
			State = 447;
			parameters();
			State = 448;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexerMemberDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifiersContext modifiers() {
			return GetRuleContext<ModifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THIS() { return GetToken(KScrParser.THIS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexerDeclContext indexerDecl() {
			return GetRuleContext<IndexerDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropBlockContext propBlock() {
			return GetRuleContext<PropBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext[] annotation() {
			return GetRuleContexts<AnnotationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext annotation(int i) {
			return GetRuleContext<AnnotationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeDefsContext genericTypeDefs() {
			return GetRuleContext<GenericTypeDefsContext>(0);
		}
		public IndexerMemberDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexerMemberDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIndexerMemberDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIndexerMemberDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexerMemberDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexerMemberDeclContext indexerMemberDecl() {
		IndexerMemberDeclContext _localctx = new IndexerMemberDeclContext(Context, State);
		EnterRule(_localctx, 64, RULE_indexerMemberDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 453;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AT) {
				{
				{
				State = 450;
				annotation();
				}
				}
				State = 455;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 456;
			modifiers();
			State = 458;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESSER) {
				{
				State = 457;
				genericTypeDefs();
				}
			}

			State = 460;
			type();
			State = 461;
			Match(THIS);
			State = 462;
			indexerDecl();
			State = 463;
			propBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropGetterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GET() { return GetToken(KScrParser.GET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		public PropGetterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propGetter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropGetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropGetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropGetter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropGetterContext propGetter() {
		PropGetterContext _localctx = new PropGetterContext(Context, State);
		EnterRule(_localctx, 66, RULE_propGetter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 465;
			Match(GET);
			State = 466;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropSetterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(KScrParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		public PropSetterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propSetter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropSetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropSetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropSetter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropSetterContext propSetter() {
		PropSetterContext _localctx = new PropSetterContext(Context, State);
		EnterRule(_localctx, 68, RULE_propSetter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 468;
			Match(SET);
			State = 469;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropInitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INIT() { return GetToken(KScrParser.INIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		public PropInitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propInit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropInit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropInit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropInit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropInitContext propInit() {
		PropInitContext _localctx = new PropInitContext(Context, State);
		EnterRule(_localctx, 70, RULE_propInit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 471;
			Match(INIT);
			State = 472;
			memberBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropBlockContext : ParserRuleContext {
		public PropBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propBlock; } }
	 
		public PropBlockContext() { }
		public virtual void CopyFrom(PropBlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PropAccessorsContext : PropBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(KScrParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropGetterContext propGetter() {
			return GetRuleContext<PropGetterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(KScrParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropSetterContext propSetter() {
			return GetRuleContext<PropSetterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropInitContext propInit() {
			return GetRuleContext<PropInitContext>(0);
		}
		public PropAccessorsContext(PropBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropAccessors(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropAccessors(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropAccessors(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PropFieldStyleContext : PropBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public PropFieldStyleContext(PropBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropFieldStyle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropFieldStyle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropFieldStyle(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PropComputedContext : PropBlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public MemberBlockContext memberBlock() {
			return GetRuleContext<MemberBlockContext>(0);
		}
		public PropComputedContext(PropBlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropComputed(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropComputed(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropComputed(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropBlockContext propBlock() {
		PropBlockContext _localctx = new PropBlockContext(Context, State);
		EnterRule(_localctx, 72, RULE_propBlock);
		int _la;
		try {
			State = 490;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				_localctx = new PropComputedContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 474;
				memberBlock();
				}
				break;
			case 2:
				_localctx = new PropAccessorsContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 475;
				Match(LBRACE);
				State = 476;
				propGetter();
				State = 478;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SET) {
					{
					State = 477;
					propSetter();
					}
				}

				State = 481;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==INIT) {
					{
					State = 480;
					propInit();
					}
				}

				State = 483;
				Match(RBRACE);
				}
				break;
			case 3:
				_localctx = new PropFieldStyleContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 487;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ASSIGN) {
					{
					State = 485;
					Match(ASSIGN);
					State = 486;
					expr(0);
					}
				}

				State = 489;
				Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifiersContext modifiers() {
			return GetRuleContext<ModifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropBlockContext propBlock() {
			return GetRuleContext<PropBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext[] annotation() {
			return GetRuleContexts<AnnotationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext annotation(int i) {
			return GetRuleContext<AnnotationContext>(i);
		}
		public PropertyDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterPropertyDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitPropertyDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyDeclContext propertyDecl() {
		PropertyDeclContext _localctx = new PropertyDeclContext(Context, State);
		EnterRule(_localctx, 74, RULE_propertyDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 495;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AT) {
				{
				{
				State = 492;
				annotation();
				}
				}
				State = 497;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 498;
			modifiers();
			State = 499;
			type();
			State = 500;
			idPart();
			State = 501;
			propBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MemberContext : ParserRuleContext {
		public MemberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_member; } }
	 
		public MemberContext() { }
		public virtual void CopyFrom(MemberContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MemInitContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public InitDeclContext initDecl() {
			return GetRuleContext<InitDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public MemInitContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemInit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemInit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemInit(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemClsContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public ClassDeclContext classDecl() {
			return GetRuleContext<ClassDeclContext>(0);
		}
		public MemClsContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemCls(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemCls(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemCls(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemCtorContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstructorDeclContext constructorDecl() {
			return GetRuleContext<ConstructorDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public MemCtorContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemCtor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemCtor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemCtor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemMtdContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public MethodDeclContext methodDecl() {
			return GetRuleContext<MethodDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public MemMtdContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemMtd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemMtd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemMtd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemIdxContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexerMemberDeclContext indexerMemberDecl() {
			return GetRuleContext<IndexerMemberDeclContext>(0);
		}
		public MemIdxContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemIdx(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemIdx(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemIdx(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemPropContext : MemberContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyDeclContext propertyDecl() {
			return GetRuleContext<PropertyDeclContext>(0);
		}
		public MemPropContext(MemberContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMemProp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMemProp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemProp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MemberContext member() {
		MemberContext _localctx = new MemberContext(Context, State);
		EnterRule(_localctx, 76, RULE_member);
		int _la;
		try {
			State = 518;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,51,Context) ) {
			case 1:
				_localctx = new MemPropContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 503;
				propertyDecl();
				}
				break;
			case 2:
				_localctx = new MemClsContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 504;
				classDecl();
				}
				break;
			case 3:
				_localctx = new MemInitContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 505;
				initDecl();
				State = 507;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CATCH || _la==FINALLY) {
					{
					State = 506;
					catchBlocks();
					}
				}

				}
				break;
			case 4:
				_localctx = new MemCtorContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 509;
				constructorDecl();
				State = 511;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CATCH || _la==FINALLY) {
					{
					State = 510;
					catchBlocks();
					}
				}

				}
				break;
			case 5:
				_localctx = new MemMtdContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 513;
				methodDecl();
				State = 515;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==CATCH || _la==FINALLY) {
					{
					State = 514;
					catchBlocks();
					}
				}

				}
				break;
			case 6:
				_localctx = new MemIdxContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 517;
				indexerMemberDecl();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClassDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ModifiersContext modifiers() {
			return GetRuleContext<ModifiersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ClassTypeContext classType() {
			return GetRuleContext<ClassTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(KScrParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(KScrParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext[] annotation() {
			return GetRuleContexts<AnnotationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AnnotationContext annotation(int i) {
			return GetRuleContext<AnnotationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeDefsContext genericTypeDefs() {
			return GetRuleContext<GenericTypeDefsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectExtendsContext objectExtends() {
			return GetRuleContext<ObjectExtendsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectImplementsContext objectImplements() {
			return GetRuleContext<ObjectImplementsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext[] member() {
			return GetRuleContexts<MemberContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MemberContext member(int i) {
			return GetRuleContext<MemberContext>(i);
		}
		public ClassDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_classDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterClassDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitClassDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClassDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClassDeclContext classDecl() {
		ClassDeclContext _localctx = new ClassDeclContext(Context, State);
		EnterRule(_localctx, 78, RULE_classDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 523;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AT) {
				{
				{
				State = 520;
				annotation();
				}
				}
				State = 525;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 526;
			modifiers();
			State = 527;
			classType();
			State = 528;
			idPart();
			State = 530;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LESSER) {
				{
				State = 529;
				genericTypeDefs();
				}
			}

			State = 533;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXTENDS) {
				{
				State = 532;
				objectExtends();
				}
			}

			State = 536;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IMPLEMENTS) {
				{
				State = 535;
				objectImplements();
				}
			}

			State = 547;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LBRACE:
				{
				State = 538;
				Match(LBRACE);
				State = 542;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PUBLIC) | (1L << INTERNAL) | (1L << PROTECTED) | (1L << PRIVATE) | (1L << STATIC) | (1L << FINAL) | (1L << ABSTRACT) | (1L << NATIVE) | (1L << SYNCHRONIZED) | (1L << CLASS) | (1L << INTERFACE) | (1L << ENUM) | (1L << ANNOTATION) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID))) != 0) || ((((_la - 93)) & ~0x3f) == 0 && ((1L << (_la - 93)) & ((1L << (AT - 93)) | (1L << (LESSER - 93)) | (1L << (ID - 93)))) != 0)) {
					{
					{
					State = 539;
					member();
					}
					}
					State = 544;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 545;
				Match(RBRACE);
				}
				break;
			case SEMICOLON:
				{
				State = 546;
				Match(SEMICOLON);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PackageDeclContext packageDecl() {
			return GetRuleContext<PackageDeclContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportsContext imports() {
			return GetRuleContext<ImportsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(KScrParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ClassDeclContext[] classDecl() {
			return GetRuleContexts<ClassDeclContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ClassDeclContext classDecl(int i) {
			return GetRuleContext<ClassDeclContext>(i);
		}
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(Context, State);
		EnterRule(_localctx, 80, RULE_file);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 549;
			packageDecl();
			State = 550;
			imports();
			State = 554;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PUBLIC) | (1L << INTERNAL) | (1L << PROTECTED) | (1L << PRIVATE) | (1L << STATIC) | (1L << FINAL) | (1L << ABSTRACT) | (1L << NATIVE) | (1L << SYNCHRONIZED) | (1L << CLASS) | (1L << INTERFACE) | (1L << ENUM) | (1L << ANNOTATION))) != 0) || _la==AT) {
				{
				{
				State = 551;
				classDecl();
				}
				}
				State = 556;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 557;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InferTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VOID() { return GetToken(KScrParser.VOID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VAR() { return GetToken(KScrParser.VAR, 0); }
		public InferTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inferType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterInferType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitInferType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInferType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InferTypeContext inferType() {
		InferTypeContext _localctx = new InferTypeContext(Context, State);
		EnterRule(_localctx, 82, RULE_inferType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 559;
			_la = TokenStream.LA(1);
			if ( !(_la==VOID || _la==VAR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexerEmptyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSQUAR() { return GetToken(KScrParser.LSQUAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSQUAR() { return GetToken(KScrParser.RSQUAR, 0); }
		public IndexerEmptyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexerEmpty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIndexerEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIndexerEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexerEmpty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexerEmptyContext indexerEmpty() {
		IndexerEmptyContext _localctx = new IndexerEmptyContext(Context, State);
		EnterRule(_localctx, 84, RULE_indexerEmpty);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 561;
			Match(LSQUAR);
			State = 562;
			Match(RSQUAR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexerDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSQUAR() { return GetToken(KScrParser.LSQUAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext[] idPart() {
			return GetRuleContexts<IdPartContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart(int i) {
			return GetRuleContext<IdPartContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSQUAR() { return GetToken(KScrParser.RSQUAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public IndexerDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexerDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIndexerDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIndexerDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexerDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexerDeclContext indexerDecl() {
		IndexerDeclContext _localctx = new IndexerDeclContext(Context, State);
		EnterRule(_localctx, 86, RULE_indexerDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 564;
			Match(LSQUAR);
			State = 565;
			type();
			State = 566;
			idPart();
			State = 573;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 567;
				Match(COMMA);
				State = 568;
				type();
				State = 569;
				idPart();
				}
				}
				State = 575;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 576;
			Match(RSQUAR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexerExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSQUAR() { return GetToken(KScrParser.LSQUAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSQUAR() { return GetToken(KScrParser.RSQUAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public IndexerExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexerExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIndexerExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIndexerExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexerExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexerExprContext indexerExpr() {
		IndexerExprContext _localctx = new IndexerExprContext(Context, State);
		EnterRule(_localctx, 88, RULE_indexerExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 578;
			Match(LSQUAR);
			State = 579;
			expr(0);
			State = 584;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 580;
				Match(COMMA);
				State = 581;
				expr(0);
				}
				}
				State = 586;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 587;
			Match(RSQUAR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CastContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		public CastContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cast; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCast(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastContext cast() {
		CastContext _localctx = new CastContext(Context, State);
		EnterRule(_localctx, 90, RULE_cast);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 589;
			Match(LPAREN);
			State = 590;
			type();
			State = 591;
			Match(COLON);
			State = 592;
			expr(0);
			State = 593;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 92, RULE_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 595;
			type();
			State = 596;
			idPart();
			State = 599;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,61,Context) ) {
			case 1:
				{
				State = 597;
				Match(ASSIGN);
				State = 598;
				expr(0);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MutationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BinaryopContext binaryop() {
			return GetRuleContext<BinaryopContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Binaryop_lateContext binaryop_late() {
			return GetRuleContext<Binaryop_lateContext>(0);
		}
		public MutationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mutation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMutation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMutation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMutation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MutationContext mutation() {
		MutationContext _localctx = new MutationContext(Context, State);
		EnterRule(_localctx, 94, RULE_mutation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 603;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EXCLAMATION:
			case QUESTION:
			case AND:
			case OR:
			case BITAND:
			case BITOR:
			case UP:
			case STAR:
			case SLASH:
			case PERCENT:
			case LSHIFT:
			case RSHIFT:
			case ULSHIFT:
			case URSHIFT:
			case EQUAL:
			case INEQUAL:
			case GREATEREQ:
			case LESSEREQ:
			case GREATER:
			case LESSER:
				{
				State = 601;
				binaryop();
				}
				break;
			case PLUS:
			case MINUS:
				{
				State = 602;
				binaryop_late();
				}
				break;
			case ASSIGN:
				break;
			default:
				break;
			}
			State = 605;
			Match(ASSIGN);
			State = 606;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public CallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_call; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallContext call() {
		CallContext _localctx = new CallContext(Context, State);
		EnterRule(_localctx, 96, RULE_call);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 608;
			idPart();
			State = 609;
			arguments();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CtorCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(KScrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public CtorCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ctorCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCtorCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCtorCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCtorCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CtorCallContext ctorCall() {
		CtorCallContext _localctx = new CtorCallContext(Context, State);
		EnterRule(_localctx, 98, RULE_ctorCall);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 611;
			Match(NEW);
			State = 612;
			type();
			State = 613;
			arguments();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewArrayContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(KScrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexerExprContext indexerExpr() {
			return GetRuleContext<IndexerExprContext>(0);
		}
		public NewArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newArray; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNewArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNewArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewArray(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewArrayContext newArray() {
		NewArrayContext _localctx = new NewArrayContext(Context, State);
		EnterRule(_localctx, 100, RULE_newArray);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 615;
			Match(NEW);
			State = 616;
			type();
			State = 617;
			indexerExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NewListedArrayContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(KScrParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IndexerEmptyContext indexerEmpty() {
			return GetRuleContext<IndexerEmptyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(KScrParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(KScrParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public NewListedArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_newListedArray; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNewListedArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNewListedArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewListedArray(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NewListedArrayContext newListedArray() {
		NewListedArrayContext _localctx = new NewListedArrayContext(Context, State);
		EnterRule(_localctx, 102, RULE_newListedArray);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 619;
			Match(NEW);
			State = 620;
			type();
			State = 621;
			indexerEmpty();
			State = 622;
			Match(LBRACE);
			State = 631;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ENUM) | (1L << ANNOTATION) | (1L << THROW) | (1L << NEW) | (1L << YIELD) | (1L << SWITCH) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID) | (1L << NUMLIT) | (1L << STRLIT) | (1L << STDIOLIT) | (1L << ENDLLIT) | (1L << NULL) | (1L << TRUE) | (1L << FALSE) | (1L << THIS) | (1L << SUPER))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (LPAREN - 64)) | (1L << (EXCLAMATION - 64)) | (1L << (PLUSPLUS - 64)) | (1L << (MINUSMINUS - 64)) | (1L << (MINUS - 64)) | (1L << (ID - 64)))) != 0)) {
				{
				State = 623;
				expr(0);
				State = 628;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 624;
					Match(COMMA);
					State = 625;
					expr(0);
					}
					}
					State = 630;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 633;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WS() { return GetToken(KScrParser.WS, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 104, RULE_label);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 635;
			idPart();
			State = 636;
			Match(COLON);
			State = 637;
			Match(WS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LambdaContext : ParserRuleContext {
		public LambdaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lambda; } }
	 
		public LambdaContext() { }
		public virtual void CopyFrom(LambdaContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class LambdaExprContext : LambdaContext {
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext tupleExpr() {
			return GetRuleContext<TupleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LambdaBlockContext lambdaBlock() {
			return GetRuleContext<LambdaBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public LambdaExprContext(LambdaContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterLambdaExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitLambdaExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLambdaExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MethodRefContext : LambdaContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public MethodRefContext(LambdaContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMethodRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMethodRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethodRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LambdaContext lambda() {
		LambdaContext _localctx = new LambdaContext(Context, State);
		EnterRule(_localctx, 106, RULE_lambda);
		int _la;
		try {
			State = 652;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
			case 1:
				_localctx = new MethodRefContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 640;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
				case 1:
					{
					State = 639;
					label();
					}
					break;
				}
				State = 642;
				type();
				State = 643;
				Match(COLON);
				State = 644;
				idPart();
				}
				break;
			case 2:
				_localctx = new LambdaExprContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 647;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ANNOTATION || _la==ID) {
					{
					State = 646;
					label();
					}
				}

				State = 649;
				tupleExpr();
				State = 650;
				lambdaBlock();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(KScrParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YIELD() { return GetToken(KScrParser.YIELD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterReturnStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitReturnStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 108, RULE_returnStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 655;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==YIELD) {
				{
				State = 654;
				Match(YIELD);
				}
			}

			State = 657;
			Match(RETURN);
			State = 659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ENUM) | (1L << ANNOTATION) | (1L << THROW) | (1L << NEW) | (1L << YIELD) | (1L << SWITCH) | (1L << OBJECT) | (1L << ARRAYIDENT) | (1L << TUPLEIDENT) | (1L << TYPE) | (1L << NUMIDENT) | (1L << BYTE) | (1L << SHORT) | (1L << INT) | (1L << LONG) | (1L << FLOAT) | (1L << DOUBLE) | (1L << VOID) | (1L << NUMLIT) | (1L << STRLIT) | (1L << STDIOLIT) | (1L << ENDLLIT) | (1L << NULL) | (1L << TRUE) | (1L << FALSE) | (1L << THIS) | (1L << SUPER))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (LPAREN - 64)) | (1L << (EXCLAMATION - 64)) | (1L << (PLUSPLUS - 64)) | (1L << (MINUSMINUS - 64)) | (1L << (MINUS - 64)) | (1L << (ID - 64)))) != 0)) {
				{
				State = 658;
				expr(0);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThrowStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THROW() { return GetToken(KScrParser.THROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ThrowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_throwStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterThrowStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitThrowStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitThrowStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ThrowStatementContext throwStatement() {
		ThrowStatementContext _localctx = new ThrowStatementContext(Context, State);
		EnterRule(_localctx, 110, RULE_throwStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 661;
			Match(THROW);
			State = 662;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MarkStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MARK() { return GetToken(KScrParser.MARK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public MarkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_markStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterMarkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitMarkStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMarkStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MarkStatementContext markStatement() {
		MarkStatementContext _localctx = new MarkStatementContext(Context, State);
		EnterRule(_localctx, 112, RULE_markStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 664;
			Match(MARK);
			State = 665;
			idPart();
			State = 666;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class JumpStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JUMP() { return GetToken(KScrParser.JUMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public JumpStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jumpStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitJumpStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJumpStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public JumpStatementContext jumpStatement() {
		JumpStatementContext _localctx = new JumpStatementContext(Context, State);
		EnterRule(_localctx, 114, RULE_jumpStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 668;
			Match(JUMP);
			State = 669;
			idPart();
			State = 670;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TryCatchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRY() { return GetToken(KScrParser.TRY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		public TryCatchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tryCatchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTryCatchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTryCatchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTryCatchStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TryCatchStatementContext tryCatchStatement() {
		TryCatchStatementContext _localctx = new TryCatchStatementContext(Context, State);
		EnterRule(_localctx, 116, RULE_tryCatchStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 672;
			Match(TRY);
			State = 673;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TryWithResourcesStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRY() { return GetToken(KScrParser.TRY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public TryWithResourcesStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tryWithResourcesStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTryWithResourcesStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTryWithResourcesStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTryWithResourcesStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TryWithResourcesStatementContext tryWithResourcesStatement() {
		TryWithResourcesStatementContext _localctx = new TryWithResourcesStatementContext(Context, State);
		EnterRule(_localctx, 118, RULE_tryWithResourcesStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 675;
			Match(TRY);
			State = 676;
			Match(LPAREN);
			State = 677;
			declaration();
			State = 682;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 678;
				Match(COMMA);
				State = 679;
				declaration();
				}
				}
				State = 684;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 685;
			Match(RPAREN);
			State = 686;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CatchBlocksContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FinallyBlockContext finallyBlock() {
			return GetRuleContext<FinallyBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlockContext[] catchBlock() {
			return GetRuleContexts<CatchBlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlockContext catchBlock(int i) {
			return GetRuleContext<CatchBlockContext>(i);
		}
		public CatchBlocksContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_catchBlocks; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCatchBlocks(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCatchBlocks(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCatchBlocks(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CatchBlocksContext catchBlocks() {
		CatchBlocksContext _localctx = new CatchBlocksContext(Context, State);
		EnterRule(_localctx, 120, RULE_catchBlocks);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 691;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CATCH) {
				{
				{
				State = 688;
				catchBlock();
				}
				}
				State = 693;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 694;
			finallyBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CatchBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CATCH() { return GetToken(KScrParser.CATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext[] type() {
			return GetRuleContexts<TypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type(int i) {
			return GetRuleContext<TypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public CatchBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_catchBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCatchBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCatchBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCatchBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CatchBlockContext catchBlock() {
		CatchBlockContext _localctx = new CatchBlockContext(Context, State);
		EnterRule(_localctx, 122, RULE_catchBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 696;
			Match(CATCH);
			State = 709;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
			case 1:
				{
				State = 697;
				Match(LPAREN);
				State = 698;
				type();
				State = 703;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 699;
					Match(COMMA);
					State = 700;
					type();
					}
					}
					State = 705;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 706;
				idPart();
				State = 707;
				Match(RPAREN);
				}
				break;
			}
			State = 711;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FinallyBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINALLY() { return GetToken(KScrParser.FINALLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		public FinallyBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_finallyBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterFinallyBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitFinallyBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFinallyBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FinallyBlockContext finallyBlock() {
		FinallyBlockContext _localctx = new FinallyBlockContext(Context, State);
		EnterRule(_localctx, 124, RULE_finallyBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 713;
			Match(FINALLY);
			State = 714;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(KScrParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseStatementContext elseStatement() {
			return GetRuleContext<ElseStatementContext>(0);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 126, RULE_ifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 716;
			Match(IF);
			State = 717;
			Match(LPAREN);
			State = 718;
			expr(0);
			State = 719;
			Match(RPAREN);
			State = 720;
			codeBlock();
			State = 722;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				{
				State = 721;
				elseStatement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(KScrParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		public ElseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseStatementContext elseStatement() {
		ElseStatementContext _localctx = new ElseStatementContext(Context, State);
		EnterRule(_localctx, 128, RULE_elseStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 724;
			Match(ELSE);
			State = 725;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(KScrParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		public WhileStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterWhileStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitWhileStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStatementContext whileStatement() {
		WhileStatementContext _localctx = new WhileStatementContext(Context, State);
		EnterRule(_localctx, 130, RULE_whileStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 727;
			Match(WHILE);
			State = 728;
			Match(LPAREN);
			State = 729;
			expr(0);
			State = 730;
			Match(RPAREN);
			State = 731;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForStatementContext : ParserRuleContext {
		public StatementContext init;
		public ExprContext cond;
		public ExprContext acc;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(KScrParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ForStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterForStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitForStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForStatementContext forStatement() {
		ForStatementContext _localctx = new ForStatementContext(Context, State);
		EnterRule(_localctx, 132, RULE_forStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 733;
			Match(FOR);
			State = 734;
			Match(LPAREN);
			State = 735;
			_localctx.init = statement();
			State = 736;
			_localctx.cond = expr(0);
			State = 737;
			Match(SEMICOLON);
			State = 738;
			_localctx.acc = expr(0);
			State = 739;
			Match(RPAREN);
			State = 740;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeachStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREACH() { return GetToken(KScrParser.FOREACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		public ForeachStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreachStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterForeachStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitForeachStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeachStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForeachStatementContext foreachStatement() {
		ForeachStatementContext _localctx = new ForeachStatementContext(Context, State);
		EnterRule(_localctx, 134, RULE_foreachStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 742;
			Match(FOREACH);
			State = 743;
			Match(LPAREN);
			State = 744;
			idPart();
			State = 745;
			Match(COLON);
			State = 746;
			expr(0);
			State = 747;
			Match(RPAREN);
			State = 748;
			codeBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DoWhileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DO() { return GetToken(KScrParser.DO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CodeBlockContext codeBlock() {
			return GetRuleContext<CodeBlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHILE() { return GetToken(KScrParser.WHILE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public DoWhileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doWhile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterDoWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitDoWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoWhile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DoWhileContext doWhile() {
		DoWhileContext _localctx = new DoWhileContext(Context, State);
		EnterRule(_localctx, 136, RULE_doWhile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 750;
			Match(DO);
			State = 751;
			codeBlock();
			State = 752;
			Match(WHILE);
			State = 753;
			Match(LPAREN);
			State = 754;
			expr(0);
			State = 755;
			Match(RPAREN);
			State = 756;
			Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SWITCH() { return GetToken(KScrParser.SWITCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext tupleExpr() {
			return GetRuleContext<TupleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(KScrParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(KScrParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CaseClauseContext[] caseClause() {
			return GetRuleContexts<CaseClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseClauseContext caseClause(int i) {
			return GetRuleContext<CaseClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultClauseContext defaultClause() {
			return GetRuleContext<DefaultClauseContext>(0);
		}
		public SwitchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterSwitchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitSwitchStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchStatementContext switchStatement() {
		SwitchStatementContext _localctx = new SwitchStatementContext(Context, State);
		EnterRule(_localctx, 138, RULE_switchStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 758;
			Match(SWITCH);
			State = 759;
			tupleExpr();
			State = 760;
			Match(LBRACE);
			State = 764;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==CASE) {
				{
				{
				State = 761;
				caseClause();
				}
				}
				State = 766;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 768;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT) {
				{
				State = 767;
				defaultClause();
				}
			}

			State = 770;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(KScrParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext tupleExpr() {
			return GetRuleContext<TupleExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseBlockContext caseBlock() {
			return GetRuleContext<CaseBlockContext>(0);
		}
		public CaseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCaseClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseClauseContext caseClause() {
		CaseClauseContext _localctx = new CaseClauseContext(Context, State);
		EnterRule(_localctx, 140, RULE_caseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 772;
			Match(CASE);
			State = 773;
			tupleExpr();
			State = 774;
			caseBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(KScrParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CaseBlockContext caseBlock() {
			return GetRuleContext<CaseBlockContext>(0);
		}
		public DefaultClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterDefaultClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitDefaultClause(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefaultClauseContext defaultClause() {
		DefaultClauseContext _localctx = new DefaultClauseContext(Context, State);
		EnterRule(_localctx, 142, RULE_defaultClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 776;
			Match(DEFAULT);
			State = 777;
			caseBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StmtForeachContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForeachStatementContext foreachStatement() {
			return GetRuleContext<ForeachStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtForeachContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtForeach(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtForeach(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtForeach(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtTryWithResContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public TryWithResourcesStatementContext tryWithResourcesStatement() {
			return GetRuleContext<TryWithResourcesStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtTryWithResContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtTryWithRes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtTryWithRes(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtTryWithRes(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtDoWhileContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public DoWhileContext doWhile() {
			return GetRuleContext<DoWhileContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtDoWhileContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtDoWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtDoWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtDoWhile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtPipeListenContext : StatementContext {
		public ExprContext pipe;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RREQARROW() { return GetTokens(KScrParser.RREQARROW); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RREQARROW(int i) {
			return GetToken(KScrParser.RREQARROW, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LambdaContext[] lambda() {
			return GetRuleContexts<LambdaContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LambdaContext lambda(int i) {
			return GetRuleContext<LambdaContext>(i);
		}
		public StmtPipeListenContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtPipeListen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtPipeListen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtPipeListen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtThrowContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ThrowStatementContext throwStatement() {
			return GetRuleContext<ThrowStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public StmtThrowContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtThrow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtThrow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtThrow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtSwitchContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public SwitchStatementContext switchStatement() {
			return GetRuleContext<SwitchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtSwitchContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtSwitch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtSwitch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtCallMemberContext : StatementContext {
		public ExprContext left;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(KScrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public StmtCallMemberContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtCallMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtCallMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtCallMember(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtWhileContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public WhileStatementContext whileStatement() {
			return GetRuleContext<WhileStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtWhileContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtWhile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtWhile(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtDeclareContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public StmtDeclareContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtDeclare(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtDeclare(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtDeclare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtMarkContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public MarkStatementContext markStatement() {
			return GetRuleContext<MarkStatementContext>(0);
		}
		public StmtMarkContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtMark(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtMark(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtMark(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtForContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ForStatementContext forStatement() {
			return GetRuleContext<ForStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtForContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtFor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtFor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtFor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtJumpContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public JumpStatementContext jumpStatement() {
			return GetRuleContext<JumpStatementContext>(0);
		}
		public StmtJumpContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtJump(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtJump(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtJump(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtIfContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtIfContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtIf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtIf(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtIf(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtPipeReadContext : StatementContext {
		public ExprContext pipe;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RRDASHARROW() { return GetTokens(KScrParser.RRDASHARROW); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RRDASHARROW(int i) {
			return GetToken(KScrParser.RRDASHARROW, i);
		}
		public StmtPipeReadContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtPipeRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtPipeRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtPipeRead(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtPipeWriteContext : StatementContext {
		public ExprContext pipe;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LLDASHARROW() { return GetTokens(KScrParser.LLDASHARROW); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LLDASHARROW(int i) {
			return GetToken(KScrParser.LLDASHARROW, i);
		}
		public StmtPipeWriteContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtPipeWrite(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtPipeWrite(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtPipeWrite(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtEmptyContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public StmtEmptyContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtEmpty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtEmpty(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtReturnContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		public StmtReturnContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtReturn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtReturn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtReturn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtAssignContext : StatementContext {
		public ExprContext left;
		[System.Diagnostics.DebuggerNonUserCode] public MutationContext mutation() {
			return GetRuleContext<MutationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(KScrParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StmtAssignContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtAssign(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtAssignTupleContext : StatementContext {
		public TupleExprContext left;
		public TupleExprContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(KScrParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext[] tupleExpr() {
			return GetRuleContexts<TupleExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext tupleExpr(int i) {
			return GetRuleContext<TupleExprContext>(i);
		}
		public StmtAssignTupleContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtAssignTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtAssignTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtAssignTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StmtTryCatchContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public TryCatchStatementContext tryCatchStatement() {
			return GetRuleContext<TryCatchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchBlocksContext catchBlocks() {
			return GetRuleContext<CatchBlocksContext>(0);
		}
		public StmtTryCatchContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterStmtTryCatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitStmtTryCatch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmtTryCatch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 144, RULE_statement);
		int _la;
		try {
			State = 864;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,89,Context) ) {
			case 1:
				_localctx = new StmtDeclareContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 779;
				declaration();
				State = 780;
				Match(SEMICOLON);
				}
				break;
			case 2:
				_localctx = new StmtAssignContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 782;
				((StmtAssignContext)_localctx).left = expr(0);
				State = 783;
				mutation();
				State = 784;
				Match(SEMICOLON);
				}
				break;
			case 3:
				_localctx = new StmtAssignTupleContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 786;
				((StmtAssignTupleContext)_localctx).left = tupleExpr();
				State = 787;
				Match(ASSIGN);
				State = 788;
				((StmtAssignTupleContext)_localctx).right = tupleExpr();
				}
				break;
			case 4:
				_localctx = new StmtCallMemberContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 790;
				((StmtCallMemberContext)_localctx).left = expr(0);
				State = 791;
				Match(DOT);
				State = 792;
				idPart();
				State = 794;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,77,Context) ) {
				case 1:
					{
					State = 793;
					arguments();
					}
					break;
				}
				}
				break;
			case 5:
				_localctx = new StmtReturnContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 796;
				returnStatement();
				State = 797;
				Match(SEMICOLON);
				}
				break;
			case 6:
				_localctx = new StmtThrowContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 799;
				throwStatement();
				State = 800;
				Match(SEMICOLON);
				}
				break;
			case 7:
				_localctx = new StmtMarkContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 802;
				markStatement();
				}
				break;
			case 8:
				_localctx = new StmtJumpContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 803;
				jumpStatement();
				}
				break;
			case 9:
				_localctx = new StmtTryCatchContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 804;
				tryCatchStatement();
				State = 806;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,78,Context) ) {
				case 1:
					{
					State = 805;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 10:
				_localctx = new StmtTryWithResContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 808;
				tryWithResourcesStatement();
				State = 810;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,79,Context) ) {
				case 1:
					{
					State = 809;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 11:
				_localctx = new StmtIfContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 812;
				ifStatement();
				State = 814;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,80,Context) ) {
				case 1:
					{
					State = 813;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 12:
				_localctx = new StmtWhileContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 816;
				whileStatement();
				State = 818;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,81,Context) ) {
				case 1:
					{
					State = 817;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 13:
				_localctx = new StmtDoWhileContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 820;
				doWhile();
				State = 822;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,82,Context) ) {
				case 1:
					{
					State = 821;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 14:
				_localctx = new StmtForContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 824;
				forStatement();
				State = 826;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,83,Context) ) {
				case 1:
					{
					State = 825;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 15:
				_localctx = new StmtForeachContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 828;
				foreachStatement();
				State = 830;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,84,Context) ) {
				case 1:
					{
					State = 829;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 16:
				_localctx = new StmtSwitchContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 832;
				switchStatement();
				State = 834;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,85,Context) ) {
				case 1:
					{
					State = 833;
					catchBlocks();
					}
					break;
				}
				}
				break;
			case 17:
				_localctx = new StmtPipeListenContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 836;
				((StmtPipeListenContext)_localctx).pipe = expr(0);
				State = 839;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 837;
					Match(RREQARROW);
					State = 838;
					lambda();
					}
					}
					State = 841;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==RREQARROW );
				State = 843;
				Match(SEMICOLON);
				}
				break;
			case 18:
				_localctx = new StmtPipeReadContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 845;
				((StmtPipeReadContext)_localctx).pipe = expr(0);
				State = 848;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 846;
					Match(RRDASHARROW);
					State = 847;
					expr(0);
					}
					}
					State = 850;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==RRDASHARROW );
				State = 852;
				Match(SEMICOLON);
				}
				break;
			case 19:
				_localctx = new StmtPipeWriteContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 854;
				((StmtPipeWriteContext)_localctx).pipe = expr(0);
				State = 857;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 855;
					Match(LLDASHARROW);
					State = 856;
					expr(0);
					}
					}
					State = 859;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==LLDASHARROW );
				State = 861;
				Match(SEMICOLON);
				}
				break;
			case 20:
				_localctx = new StmtEmptyContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 863;
				Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypedExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypedExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypedExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedExprContext typedExpr() {
		TypedExprContext _localctx = new TypedExprContext(Context, State);
		EnterRule(_localctx, 146, RULE_typedExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 867;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,90,Context) ) {
			case 1:
				{
				State = 866;
				type();
				}
				break;
			}
			State = 869;
			expr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
	 
		public ExprContext() { }
		public virtual void CopyFrom(ExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ParensContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		public ParensContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterParens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitParens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParens(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpPostfixContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostfixopContext postfixop() {
			return GetRuleContext<PostfixopContext>(0);
		}
		public OpPostfixContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpPostfix(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpPostfix(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpPostfix(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprCallMemberContext : ExprContext {
		public ExprContext left;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(KScrParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public ExprCallMemberContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprCallMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprCallMember(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprCallMember(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpPrefixContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrefixopContext prefixop() {
			return GetRuleContext<PrefixopContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public OpPrefixContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpPrefix(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpPrefix(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpPrefix(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ReadIndexerContext : ExprContext {
		public ExprContext target;
		[System.Diagnostics.DebuggerNonUserCode] public IndexerExprContext indexerExpr() {
			return GetRuleContext<IndexerExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ReadIndexerContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterReadIndexer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitReadIndexer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReadIndexer(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewListedArrayValueContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public NewListedArrayContext newListedArray() {
			return GetRuleContext<NewListedArrayContext>(0);
		}
		public NewListedArrayValueContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNewListedArrayValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNewListedArrayValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewListedArrayValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprLambdaContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public LambdaContext lambda() {
			return GetRuleContext<LambdaContext>(0);
		}
		public ExprLambdaContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprLambda(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprLambda(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprLambda(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CheckInstanceofContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(KScrParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		public CheckInstanceofContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCheckInstanceof(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCheckInstanceof(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCheckInstanceof(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprCastContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public CastContext cast() {
			return GetRuleContext<CastContext>(0);
		}
		public ExprCastContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprCast(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprCast(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class YieldExprContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YIELD() { return GetToken(KScrParser.YIELD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public YieldExprContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterYieldExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitYieldExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYieldExpr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RangeInvocContext : ExprContext {
		public ExprContext left;
		public ExprContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTELIPSES() { return GetToken(KScrParser.SHORTELIPSES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public RangeInvocContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterRangeInvoc(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitRangeInvoc(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRangeInvoc(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpBinaryLateContext : ExprContext {
		public ExprContext left;
		public ExprContext right;
		[System.Diagnostics.DebuggerNonUserCode] public Binaryop_lateContext binaryop_late() {
			return GetRuleContext<Binaryop_lateContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public OpBinaryLateContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpBinaryLate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpBinaryLate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpBinaryLate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NativeLitValueContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrimitiveLitContext primitiveLit() {
			return GetRuleContext<PrimitiveLitContext>(0);
		}
		public NativeLitValueContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNativeLitValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNativeLitValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNativeLitValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprPipeListenContext : ExprContext {
		public ExprContext pipe;
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RREQARROW() { return GetTokens(KScrParser.RREQARROW); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RREQARROW(int i) {
			return GetToken(KScrParser.RREQARROW, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LambdaContext[] lambda() {
			return GetRuleContexts<LambdaContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LambdaContext lambda(int i) {
			return GetRuleContext<LambdaContext>(i);
		}
		public ExprPipeListenContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprPipeListen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprPipeListen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprPipeListen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprThrowContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public ThrowStatementContext throwStatement() {
			return GetRuleContext<ThrowStatementContext>(0);
		}
		public ExprThrowContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprThrow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprThrow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprThrow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarAssignContext : ExprContext {
		public ExprContext left;
		[System.Diagnostics.DebuggerNonUserCode] public MutationContext mutation() {
			return GetRuleContext<MutationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public VarAssignContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarAssign(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewArrayValueContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public NewArrayContext newArray() {
			return GetRuleContext<NewArrayContext>(0);
		}
		public NewArrayValueContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNewArrayValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNewArrayValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewArrayValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprSwitchContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public SwitchStatementContext switchStatement() {
			return GetRuleContext<SwitchStatementContext>(0);
		}
		public ExprSwitchContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprSwitch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprSwitch(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprSwitch(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarValueContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		public VarValueContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpBinaryContext : ExprContext {
		public ExprContext left;
		public ExprContext right;
		[System.Diagnostics.DebuggerNonUserCode] public BinaryopContext binaryop() {
			return GetRuleContext<BinaryopContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public OpBinaryContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpBinary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarDeclareContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public VarDeclareContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarDeclare(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarDeclare(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarDeclare(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExprTupleContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public TupleExprContext tupleExpr() {
			return GetRuleContext<TupleExprContext>(0);
		}
		public ExprTupleContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterExprTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitExprTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeValueContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public TypeValueContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CallCtorContext : ExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public CtorCallContext ctorCall() {
			return GetRuleContext<CtorCallContext>(0);
		}
		public CallCtorContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterCallCtor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitCallCtor(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallCtor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TernaryContext : ExprContext {
		public ExprContext cond;
		public ExprContext left;
		public ExprContext right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(KScrParser.QUESTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(KScrParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public TernaryContext(ExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTernary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTernary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTernary(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		return expr(0);
	}

	private ExprContext expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExprContext _localctx = new ExprContext(Context, _parentState);
		ExprContext _prevctx = _localctx;
		int _startState = 148;
		EnterRecursionRule(_localctx, 148, RULE_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 893;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,91,Context) ) {
			case 1:
				{
				_localctx = new VarValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 872;
				idPart();
				}
				break;
			case 2:
				{
				_localctx = new OpPrefixContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 873;
				prefixop();
				State = 874;
				expr(24);
				}
				break;
			case 3:
				{
				_localctx = new YieldExprContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 876;
				Match(YIELD);
				State = 877;
				expr(20);
				}
				break;
			case 4:
				{
				_localctx = new ParensContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 878;
				Match(LPAREN);
				State = 879;
				expr(0);
				State = 880;
				Match(RPAREN);
				}
				break;
			case 5:
				{
				_localctx = new ExprCastContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 882;
				cast();
				}
				break;
			case 6:
				{
				_localctx = new NewArrayValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 883;
				newArray();
				}
				break;
			case 7:
				{
				_localctx = new NewListedArrayValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 884;
				newListedArray();
				}
				break;
			case 8:
				{
				_localctx = new NativeLitValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 885;
				primitiveLit();
				}
				break;
			case 9:
				{
				_localctx = new TypeValueContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 886;
				type();
				}
				break;
			case 10:
				{
				_localctx = new ExprLambdaContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 887;
				lambda();
				}
				break;
			case 11:
				{
				_localctx = new VarDeclareContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 888;
				declaration();
				}
				break;
			case 12:
				{
				_localctx = new CallCtorContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 889;
				ctorCall();
				}
				break;
			case 13:
				{
				_localctx = new ExprThrowContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 890;
				throwStatement();
				}
				break;
			case 14:
				{
				_localctx = new ExprSwitchContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 891;
				switchStatement();
				}
				break;
			case 15:
				{
				_localctx = new ExprTupleContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 892;
				tupleExpr();
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 939;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,96,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 937;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,95,Context) ) {
					case 1:
						{
						_localctx = new OpBinaryContext(new ExprContext(_parentctx, _parentState));
						((OpBinaryContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 895;
						if (!(Precpred(Context, 23))) throw new FailedPredicateException(this, "Precpred(Context, 23)");
						State = 896;
						binaryop();
						State = 897;
						((OpBinaryContext)_localctx).right = expr(24);
						}
						break;
					case 2:
						{
						_localctx = new TernaryContext(new ExprContext(_parentctx, _parentState));
						((TernaryContext)_localctx).cond = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 899;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 900;
						Match(QUESTION);
						State = 901;
						((TernaryContext)_localctx).left = expr(0);
						State = 902;
						Match(COLON);
						State = 903;
						((TernaryContext)_localctx).right = expr(18);
						}
						break;
					case 3:
						{
						_localctx = new RangeInvocContext(new ExprContext(_parentctx, _parentState));
						((RangeInvocContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 905;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 906;
						Match(SHORTELIPSES);
						State = 907;
						((RangeInvocContext)_localctx).right = expr(5);
						}
						break;
					case 4:
						{
						_localctx = new OpBinaryLateContext(new ExprContext(_parentctx, _parentState));
						((OpBinaryLateContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 908;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						State = 909;
						binaryop_late();
						State = 910;
						((OpBinaryLateContext)_localctx).right = expr(2);
						}
						break;
					case 5:
						{
						_localctx = new OpPostfixContext(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 912;
						if (!(Precpred(Context, 22))) throw new FailedPredicateException(this, "Precpred(Context, 22)");
						State = 913;
						postfixop();
						}
						break;
					case 6:
						{
						_localctx = new CheckInstanceofContext(new ExprContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 914;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 915;
						Match(IS);
						State = 916;
						type();
						State = 918;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,92,Context) ) {
						case 1:
							{
							State = 917;
							idPart();
							}
							break;
						}
						}
						break;
					case 7:
						{
						_localctx = new ReadIndexerContext(new ExprContext(_parentctx, _parentState));
						((ReadIndexerContext)_localctx).target = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 920;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 921;
						indexerExpr();
						}
						break;
					case 8:
						{
						_localctx = new VarAssignContext(new ExprContext(_parentctx, _parentState));
						((VarAssignContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 922;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 923;
						mutation();
						}
						break;
					case 9:
						{
						_localctx = new ExprCallMemberContext(new ExprContext(_parentctx, _parentState));
						((ExprCallMemberContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 924;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 925;
						Match(DOT);
						State = 926;
						idPart();
						State = 928;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,93,Context) ) {
						case 1:
							{
							State = 927;
							arguments();
							}
							break;
						}
						}
						break;
					case 10:
						{
						_localctx = new ExprPipeListenContext(new ExprContext(_parentctx, _parentState));
						((ExprPipeListenContext)_localctx).pipe = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expr);
						State = 930;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 933;
						ErrorHandler.Sync(this);
						_alt = 1;
						do {
							switch (_alt) {
							case 1:
								{
								{
								State = 931;
								Match(RREQARROW);
								State = 932;
								lambda();
								}
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							State = 935;
							ErrorHandler.Sync(this);
							_alt = Interpreter.AdaptivePredict(TokenStream,94,Context);
						} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
						}
						break;
					}
					} 
				}
				State = 941;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,96,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TupleDeclTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart() {
			return GetRuleContext<IdPartContext>(0);
		}
		public TupleDeclTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleDeclType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTupleDeclType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTupleDeclType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleDeclType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleDeclTypeContext tupleDeclType() {
		TupleDeclTypeContext _localctx = new TupleDeclTypeContext(Context, State);
		EnterRule(_localctx, 150, RULE_tupleDeclType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 942;
			type();
			State = 944;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ANNOTATION || _la==ID) {
				{
				State = 943;
				idPart();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleDeclContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TupleDeclTypeContext[] tupleDeclType() {
			return GetRuleContexts<TupleDeclTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TupleDeclTypeContext tupleDeclType(int i) {
			return GetRuleContext<TupleDeclTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public TupleDeclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleDecl; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTupleDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTupleDecl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleDecl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleDeclContext tupleDecl() {
		TupleDeclContext _localctx = new TupleDeclContext(Context, State);
		EnterRule(_localctx, 152, RULE_tupleDecl);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 946;
			Match(LPAREN);
			State = 947;
			tupleDeclType();
			State = 952;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 948;
				Match(COMMA);
				State = 949;
				tupleDeclType();
				}
				}
				State = 954;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 955;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(KScrParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypedExprContext[] typedExpr() {
			return GetRuleContexts<TypedExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypedExprContext typedExpr(int i) {
			return GetRuleContext<TypedExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(KScrParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(KScrParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(KScrParser.COMMA, i);
		}
		public TupleExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tupleExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTupleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTupleExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTupleExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleExprContext tupleExpr() {
		TupleExprContext _localctx = new TupleExprContext(Context, State);
		EnterRule(_localctx, 154, RULE_tupleExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 957;
			Match(LPAREN);
			State = 958;
			typedExpr();
			State = 963;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 959;
				Match(COMMA);
				State = 960;
				typedExpr();
				}
				}
				State = 965;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 966;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryopContext : ParserRuleContext {
		public BinaryopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryop; } }
	 
		public BinaryopContext() { }
		public virtual void CopyFrom(BinaryopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OpEqualContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL() { return GetToken(KScrParser.EQUAL, 0); }
		public OpEqualContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpEqual(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpEqual(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpModulusContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(KScrParser.PERCENT, 0); }
		public OpModulusContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpModulus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpModulus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpModulus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpPowContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UP() { return GetToken(KScrParser.UP, 0); }
		public OpPowContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpPow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpPow(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpPow(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpBitOrContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITOR() { return GetToken(KScrParser.BITOR, 0); }
		public OpBitOrContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpBitOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpBitOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpBitOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLesserEqContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESSEREQ() { return GetToken(KScrParser.LESSEREQ, 0); }
		public OpLesserEqContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLesserEq(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLesserEq(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLesserEq(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLogicOrContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(KScrParser.OR, 0); }
		public OpLogicOrContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLogicOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLogicOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLogicOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpBitAndContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BITAND() { return GetToken(KScrParser.BITAND, 0); }
		public OpBitAndContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpBitAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpBitAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpBitAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLogicAndContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(KScrParser.AND, 0); }
		public OpLogicAndContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLogicAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLogicAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLogicAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpURShiftContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URSHIFT() { return GetToken(KScrParser.URSHIFT, 0); }
		public OpURShiftContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpURShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpURShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpURShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpGreaterContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(KScrParser.GREATER, 0); }
		public OpGreaterContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpGreater(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpGreater(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpGreater(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLesserContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESSER() { return GetToken(KScrParser.LESSER, 0); }
		public OpLesserContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLesser(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLesser(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLesser(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLShiftContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSHIFT() { return GetToken(KScrParser.LSHIFT, 0); }
		public OpLShiftContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpGreaterEqContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATEREQ() { return GetToken(KScrParser.GREATEREQ, 0); }
		public OpGreaterEqContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpGreaterEq(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpGreaterEq(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpGreaterEq(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpRShiftContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSHIFT() { return GetToken(KScrParser.RSHIFT, 0); }
		public OpRShiftContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpRShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpRShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpRShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpNullFallbackContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] QUESTION() { return GetTokens(KScrParser.QUESTION); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION(int i) {
			return GetToken(KScrParser.QUESTION, i);
		}
		public OpNullFallbackContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpNullFallback(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpNullFallback(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpNullFallback(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpMultiplyContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STAR() { return GetToken(KScrParser.STAR, 0); }
		public OpMultiplyContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpMultiply(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpMultiply(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpMultiply(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpDivideContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(KScrParser.SLASH, 0); }
		public OpDivideContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpDivide(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpDivide(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpDivide(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpBitNotContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(KScrParser.EXCLAMATION, 0); }
		public OpBitNotContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpBitNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpBitNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpBitNot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpInequalContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INEQUAL() { return GetToken(KScrParser.INEQUAL, 0); }
		public OpInequalContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpInequal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpInequal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpInequal(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpULShiftContext : BinaryopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ULSHIFT() { return GetToken(KScrParser.ULSHIFT, 0); }
		public OpULShiftContext(BinaryopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpULShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpULShift(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpULShift(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BinaryopContext binaryop() {
		BinaryopContext _localctx = new BinaryopContext(Context, State);
		EnterRule(_localctx, 156, RULE_binaryop);
		try {
			State = 989;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STAR:
				_localctx = new OpMultiplyContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 968;
				Match(STAR);
				}
				break;
			case SLASH:
				_localctx = new OpDivideContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 969;
				Match(SLASH);
				}
				break;
			case PERCENT:
				_localctx = new OpModulusContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 970;
				Match(PERCENT);
				}
				break;
			case BITAND:
				_localctx = new OpBitAndContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 971;
				Match(BITAND);
				}
				break;
			case BITOR:
				_localctx = new OpBitOrContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 972;
				Match(BITOR);
				}
				break;
			case EXCLAMATION:
				_localctx = new OpBitNotContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 973;
				Match(EXCLAMATION);
				}
				break;
			case AND:
				_localctx = new OpLogicAndContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 974;
				Match(AND);
				}
				break;
			case OR:
				_localctx = new OpLogicOrContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 975;
				Match(OR);
				}
				break;
			case UP:
				_localctx = new OpPowContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 976;
				Match(UP);
				}
				break;
			case EQUAL:
				_localctx = new OpEqualContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 977;
				Match(EQUAL);
				}
				break;
			case INEQUAL:
				_localctx = new OpInequalContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 978;
				Match(INEQUAL);
				}
				break;
			case GREATEREQ:
				_localctx = new OpGreaterEqContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 979;
				Match(GREATEREQ);
				}
				break;
			case LESSEREQ:
				_localctx = new OpLesserEqContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 980;
				Match(LESSEREQ);
				}
				break;
			case GREATER:
				_localctx = new OpGreaterContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 981;
				Match(GREATER);
				}
				break;
			case LESSER:
				_localctx = new OpLesserContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 982;
				Match(LESSER);
				}
				break;
			case LSHIFT:
				_localctx = new OpLShiftContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 983;
				Match(LSHIFT);
				}
				break;
			case RSHIFT:
				_localctx = new OpRShiftContext(_localctx);
				EnterOuterAlt(_localctx, 17);
				{
				State = 984;
				Match(RSHIFT);
				}
				break;
			case ULSHIFT:
				_localctx = new OpULShiftContext(_localctx);
				EnterOuterAlt(_localctx, 18);
				{
				State = 985;
				Match(ULSHIFT);
				}
				break;
			case URSHIFT:
				_localctx = new OpURShiftContext(_localctx);
				EnterOuterAlt(_localctx, 19);
				{
				State = 986;
				Match(URSHIFT);
				}
				break;
			case QUESTION:
				_localctx = new OpNullFallbackContext(_localctx);
				EnterOuterAlt(_localctx, 20);
				{
				State = 987;
				Match(QUESTION);
				State = 988;
				Match(QUESTION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Binaryop_lateContext : ParserRuleContext {
		public Binaryop_lateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryop_late; } }
	 
		public Binaryop_lateContext() { }
		public virtual void CopyFrom(Binaryop_lateContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OpPlusContext : Binaryop_lateContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(KScrParser.PLUS, 0); }
		public OpPlusContext(Binaryop_lateContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpPlus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpPlus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpPlus(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpMinusContext : Binaryop_lateContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(KScrParser.MINUS, 0); }
		public OpMinusContext(Binaryop_lateContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpMinus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpMinus(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpMinus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Binaryop_lateContext binaryop_late() {
		Binaryop_lateContext _localctx = new Binaryop_lateContext(Context, State);
		EnterRule(_localctx, 158, RULE_binaryop_late);
		try {
			State = 993;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
				_localctx = new OpPlusContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 991;
				Match(PLUS);
				}
				break;
			case MINUS:
				_localctx = new OpMinusContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 992;
				Match(MINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrefixopContext : ParserRuleContext {
		public PrefixopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prefixop; } }
	 
		public PrefixopContext() { }
		public virtual void CopyFrom(PrefixopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OpArithNotContext : PrefixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(KScrParser.MINUS, 0); }
		public OpArithNotContext(PrefixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpArithNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpArithNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpArithNot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpIncrReadContext : PrefixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUSPLUS() { return GetToken(KScrParser.PLUSPLUS, 0); }
		public OpIncrReadContext(PrefixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpIncrRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpIncrRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpIncrRead(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpLogicNotContext : PrefixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(KScrParser.EXCLAMATION, 0); }
		public OpLogicNotContext(PrefixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpLogicNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpLogicNot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpLogicNot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpDecrReadContext : PrefixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUSMINUS() { return GetToken(KScrParser.MINUSMINUS, 0); }
		public OpDecrReadContext(PrefixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpDecrRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpDecrRead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpDecrRead(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrefixopContext prefixop() {
		PrefixopContext _localctx = new PrefixopContext(Context, State);
		EnterRule(_localctx, 160, RULE_prefixop);
		try {
			State = 999;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MINUS:
				_localctx = new OpArithNotContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 995;
				Match(MINUS);
				}
				break;
			case EXCLAMATION:
				_localctx = new OpLogicNotContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 996;
				Match(EXCLAMATION);
				}
				break;
			case PLUSPLUS:
				_localctx = new OpIncrReadContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 997;
				Match(PLUSPLUS);
				}
				break;
			case MINUSMINUS:
				_localctx = new OpDecrReadContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 998;
				Match(MINUSMINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PostfixopContext : ParserRuleContext {
		public PostfixopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postfixop; } }
	 
		public PostfixopContext() { }
		public virtual void CopyFrom(PostfixopContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OpReadDecrContext : PostfixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUSMINUS() { return GetToken(KScrParser.MINUSMINUS, 0); }
		public OpReadDecrContext(PostfixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpReadDecr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpReadDecr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpReadDecr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OpReadIncrContext : PostfixopContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUSPLUS() { return GetToken(KScrParser.PLUSPLUS, 0); }
		public OpReadIncrContext(PostfixopContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterOpReadIncr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitOpReadIncr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpReadIncr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostfixopContext postfixop() {
		PostfixopContext _localctx = new PostfixopContext(Context, State);
		EnterRule(_localctx, 162, RULE_postfixop);
		try {
			State = 1003;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUSPLUS:
				_localctx = new OpReadIncrContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1001;
				Match(PLUSPLUS);
				}
				break;
			case MINUSMINUS:
				_localctx = new OpReadDecrContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1002;
				Match(MINUSMINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext[] idPart() {
			return GetRuleContexts<IdPartContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdPartContext idPart(int i) {
			return GetRuleContext<IdPartContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(KScrParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(KScrParser.DOT, i);
		}
		public IdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterId(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitId(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdContext id() {
		IdContext _localctx = new IdContext(Context, State);
		EnterRule(_localctx, 164, RULE_id);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1005;
			idPart();
			State = 1010;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,104,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1006;
					Match(DOT);
					State = 1007;
					idPart();
					}
					} 
				}
				State = 1012;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,104,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdPartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(KScrParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANNOTATION() { return GetToken(KScrParser.ANNOTATION, 0); }
		public IdPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_idPart; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterIdPart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitIdPart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdPartContext idPart() {
		IdPartContext _localctx = new IdPartContext(Context, State);
		EnterRule(_localctx, 166, RULE_idPart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1013;
			_la = TokenStream.LA(1);
			if ( !(_la==ANNOTATION || _la==ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAYIDENT() { return GetToken(KScrParser.ARRAYIDENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeUsesContext genericTypeUses() {
			return GetRuleContext<GenericTypeUsesContext>(0);
		}
		public ArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayContext array() {
		ArrayContext _localctx = new ArrayContext(Context, State);
		EnterRule(_localctx, 168, RULE_array);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1015;
			Match(ARRAYIDENT);
			State = 1017;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,105,Context) ) {
			case 1:
				{
				State = 1016;
				genericTypeUses();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TupleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TUPLEIDENT() { return GetToken(KScrParser.TUPLEIDENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeUsesContext genericTypeUses() {
			return GetRuleContext<GenericTypeUsesContext>(0);
		}
		public TupleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tuple; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TupleContext tuple() {
		TupleContext _localctx = new TupleContext(Context, State);
		EnterRule(_localctx, 170, RULE_tuple);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1019;
			Match(TUPLEIDENT);
			State = 1021;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,106,Context) ) {
			case 1:
				{
				State = 1020;
				genericTypeUses();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumContext : ParserRuleContext {
		public NumContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_num; } }
	 
		public NumContext() { }
		public virtual void CopyFrom(NumContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class NumTypeLitTupleContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMIDENT() { return GetToken(KScrParser.NUMIDENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(KScrParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GenericTypeUsesContext genericTypeUses() {
			return GetRuleContext<GenericTypeUsesContext>(0);
		}
		public NumTypeLitTupleContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitLongContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LONG() { return GetToken(KScrParser.LONG, 0); }
		public NumTypeLitLongContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitLong(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitLong(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitLong(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitDoubleContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLE() { return GetToken(KScrParser.DOUBLE, 0); }
		public NumTypeLitDoubleContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitDouble(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitDouble(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitDouble(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitShortContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORT() { return GetToken(KScrParser.SHORT, 0); }
		public NumTypeLitShortContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitShort(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitShort(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitShort(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitByteContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BYTE() { return GetToken(KScrParser.BYTE, 0); }
		public NumTypeLitByteContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitByte(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitByte(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitByte(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitFloatContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT() { return GetToken(KScrParser.FLOAT, 0); }
		public NumTypeLitFloatContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitFloat(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitFloat(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitFloat(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumTypeLitIntContext : NumContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(KScrParser.INT, 0); }
		public NumTypeLitIntContext(NumContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterNumTypeLitInt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitNumTypeLitInt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumTypeLitInt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumContext num() {
		NumContext _localctx = new NumContext(Context, State);
		EnterRule(_localctx, 172, RULE_num);
		int _la;
		try {
			State = 1033;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,108,Context) ) {
			case 1:
				_localctx = new NumTypeLitTupleContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1023;
				_la = TokenStream.LA(1);
				if ( !(_la==NUMIDENT || _la==INT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1025;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,107,Context) ) {
				case 1:
					{
					State = 1024;
					genericTypeUses();
					}
					break;
				}
				}
				break;
			case 2:
				_localctx = new NumTypeLitByteContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1027;
				Match(BYTE);
				}
				break;
			case 3:
				_localctx = new NumTypeLitShortContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1028;
				Match(SHORT);
				}
				break;
			case 4:
				_localctx = new NumTypeLitIntContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1029;
				Match(INT);
				}
				break;
			case 5:
				_localctx = new NumTypeLitLongContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1030;
				Match(LONG);
				}
				break;
			case 6:
				_localctx = new NumTypeLitFloatContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1031;
				Match(FLOAT);
				}
				break;
			case 7:
				_localctx = new NumTypeLitDoubleContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1032;
				Match(DOUBLE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimitiveTypeLitContext : ParserRuleContext {
		public PrimitiveTypeLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primitiveTypeLit; } }
	 
		public PrimitiveTypeLitContext() { }
		public virtual void CopyFrom(PrimitiveTypeLitContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypeLitVoidContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VOID() { return GetToken(KScrParser.VOID, 0); }
		public TypeLitVoidContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitVoid(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitVoid(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitVoid(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitTupleContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public TupleContext tuple() {
			return GetRuleContext<TupleContext>(0);
		}
		public TypeLitTupleContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitTuple(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitTuple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitEnumContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENUM() { return GetToken(KScrParser.ENUM, 0); }
		public TypeLitEnumContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitEnum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitEnum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitEnum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitArrayContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayContext array() {
			return GetRuleContext<ArrayContext>(0);
		}
		public TypeLitArrayContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitArray(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitTypeContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(KScrParser.TYPE, 0); }
		public TypeLitTypeContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitType(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitObjectContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBJECT() { return GetToken(KScrParser.OBJECT, 0); }
		public TypeLitObjectContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitObject(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitObject(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitObject(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypeLitNumContext : PrimitiveTypeLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumContext num() {
			return GetRuleContext<NumContext>(0);
		}
		public TypeLitNumContext(PrimitiveTypeLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterTypeLitNum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitTypeLitNum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLitNum(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimitiveTypeLitContext primitiveTypeLit() {
		PrimitiveTypeLitContext _localctx = new PrimitiveTypeLitContext(Context, State);
		EnterRule(_localctx, 174, RULE_primitiveTypeLit);
		try {
			State = 1042;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OBJECT:
				_localctx = new TypeLitObjectContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1035;
				Match(OBJECT);
				}
				break;
			case ARRAYIDENT:
				_localctx = new TypeLitArrayContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1036;
				array();
				}
				break;
			case TUPLEIDENT:
				_localctx = new TypeLitTupleContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1037;
				tuple();
				}
				break;
			case NUMIDENT:
			case BYTE:
			case SHORT:
			case INT:
			case LONG:
			case FLOAT:
			case DOUBLE:
				_localctx = new TypeLitNumContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1038;
				num();
				}
				break;
			case TYPE:
				_localctx = new TypeLitTypeContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1039;
				Match(TYPE);
				}
				break;
			case ENUM:
				_localctx = new TypeLitEnumContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1040;
				Match(ENUM);
				}
				break;
			case VOID:
				_localctx = new TypeLitVoidContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1041;
				Match(VOID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimitiveLitContext : ParserRuleContext {
		public PrimitiveLitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primitiveLit; } }
	 
		public PrimitiveLitContext() { }
		public virtual void CopyFrom(PrimitiveLitContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class VarLitStrContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRLIT() { return GetToken(KScrParser.STRLIT, 0); }
		public VarLitStrContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitStr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitStr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitStr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitStdioContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STDIOLIT() { return GetToken(KScrParser.STDIOLIT, 0); }
		public VarLitStdioContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitStdio(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitStdio(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitStdio(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitTrueContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(KScrParser.TRUE, 0); }
		public VarLitTrueContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitTrue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitTrue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitTrue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarThisContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THIS() { return GetToken(KScrParser.THIS, 0); }
		public VarThisContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarThis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarThis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarThis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitNumContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMLIT() { return GetToken(KScrParser.NUMLIT, 0); }
		public VarLitNumContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitNum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitNum(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitNum(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitEndlContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDLLIT() { return GetToken(KScrParser.ENDLLIT, 0); }
		public VarLitEndlContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitEndl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitEndl(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitEndl(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitFalseContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(KScrParser.FALSE, 0); }
		public VarLitFalseContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitFalse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitFalse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitFalse(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarLitNullContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(KScrParser.NULL, 0); }
		public VarLitNullContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarLitNull(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarLitNull(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarLitNull(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VarSuperContext : PrimitiveLitContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPER() { return GetToken(KScrParser.SUPER, 0); }
		public VarSuperContext(PrimitiveLitContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.EnterVarSuper(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IKScrParserListener typedListener = listener as IKScrParserListener;
			if (typedListener != null) typedListener.ExitVarSuper(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IKScrParserVisitor<TResult> typedVisitor = visitor as IKScrParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarSuper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimitiveLitContext primitiveLit() {
		PrimitiveLitContext _localctx = new PrimitiveLitContext(Context, State);
		EnterRule(_localctx, 176, RULE_primitiveLit);
		try {
			State = 1053;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case THIS:
				_localctx = new VarThisContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1044;
				Match(THIS);
				}
				break;
			case SUPER:
				_localctx = new VarSuperContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1045;
				Match(SUPER);
				}
				break;
			case NUMLIT:
				_localctx = new VarLitNumContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1046;
				Match(NUMLIT);
				}
				break;
			case TRUE:
				_localctx = new VarLitTrueContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1047;
				Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new VarLitFalseContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1048;
				Match(FALSE);
				}
				break;
			case STRLIT:
				_localctx = new VarLitStrContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1049;
				Match(STRLIT);
				}
				break;
			case STDIOLIT:
				_localctx = new VarLitStdioContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1050;
				Match(STDIOLIT);
				}
				break;
			case ENDLLIT:
				_localctx = new VarLitEndlContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1051;
				Match(ENDLLIT);
				}
				break;
			case NULL:
				_localctx = new VarLitNullContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1052;
				Match(NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 74: return expr_sempred((ExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expr_sempred(ExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 23);
		case 1: return Precpred(Context, 17);
		case 2: return Precpred(Context, 4);
		case 3: return Precpred(Context, 1);
		case 4: return Precpred(Context, 22);
		case 5: return Precpred(Context, 21);
		case 6: return Precpred(Context, 19);
		case 7: return Precpred(Context, 9);
		case 8: return Precpred(Context, 8);
		case 9: return Precpred(Context, 3);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,116,1056,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
		7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,
		2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,
		2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,
		2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,1,0,1,0,1,0,1,0,1,1,5,1,184,8,
		1,10,1,12,1,187,9,1,1,2,1,2,3,2,191,8,2,1,2,1,2,1,2,3,2,196,8,2,1,2,1,
		2,1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,4,1,4,5,4,210,8,4,10,4,12,4,213,9,
		4,1,4,3,4,216,8,4,1,4,3,4,219,8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
		3,5,230,8,5,1,6,5,6,233,8,6,10,6,12,6,236,9,6,1,7,1,7,1,7,1,7,3,7,242,
		8,7,1,8,1,8,1,8,3,8,247,8,8,1,8,1,8,5,8,251,8,8,10,8,12,8,254,9,8,1,8,
		1,8,1,9,1,9,1,9,3,9,261,8,9,1,9,1,9,3,9,265,8,9,1,9,1,9,3,9,269,8,9,3,
		9,271,8,9,1,10,1,10,3,10,275,8,10,1,11,1,11,3,11,279,8,11,1,11,1,11,1,
		11,1,11,3,11,285,8,11,1,11,1,11,1,11,3,11,290,8,11,3,11,292,8,11,1,12,
		1,12,1,12,3,12,297,8,12,1,12,1,12,5,12,301,8,12,10,12,12,12,304,9,12,1,
		12,1,12,1,13,1,13,1,13,1,13,5,13,312,8,13,10,13,12,13,315,9,13,1,14,1,
		14,1,14,1,14,5,14,321,8,14,10,14,12,14,324,9,14,1,15,3,15,327,8,15,1,15,
		1,15,1,15,1,15,3,15,333,8,15,1,16,1,16,1,16,1,16,5,16,339,8,16,10,16,12,
		16,342,9,16,3,16,344,8,16,1,16,1,16,1,17,1,17,1,17,1,17,5,17,352,8,17,
		10,17,12,17,355,9,17,3,17,357,8,17,1,17,1,17,1,18,5,18,362,8,18,10,18,
		12,18,365,9,18,1,19,1,19,1,20,1,20,3,20,371,8,20,1,21,1,21,1,21,1,21,1,
		22,1,22,1,22,1,23,1,23,1,23,3,23,383,8,23,1,24,1,24,1,24,1,24,1,24,1,24,
		1,24,1,24,3,24,393,8,24,1,25,1,25,1,25,1,25,1,25,3,25,400,8,25,1,26,1,
		26,1,26,3,26,405,8,26,1,27,1,27,1,27,1,28,1,28,1,28,1,29,1,29,1,29,1,29,
		5,29,417,8,29,10,29,12,29,420,9,29,1,30,5,30,423,8,30,10,30,12,30,426,
		9,30,1,30,1,30,1,30,1,30,3,30,432,8,30,1,30,1,30,1,31,5,31,437,8,31,10,
		31,12,31,440,9,31,1,31,1,31,3,31,444,8,31,1,31,1,31,1,31,1,31,1,31,1,32,
		5,32,452,8,32,10,32,12,32,455,9,32,1,32,1,32,3,32,459,8,32,1,32,1,32,1,
		32,1,32,1,32,1,33,1,33,1,33,1,34,1,34,1,34,1,35,1,35,1,35,1,36,1,36,1,
		36,1,36,3,36,479,8,36,1,36,3,36,482,8,36,1,36,1,36,1,36,1,36,3,36,488,
		8,36,1,36,3,36,491,8,36,1,37,5,37,494,8,37,10,37,12,37,497,9,37,1,37,1,
		37,1,37,1,37,1,37,1,38,1,38,1,38,1,38,3,38,508,8,38,1,38,1,38,3,38,512,
		8,38,1,38,1,38,3,38,516,8,38,1,38,3,38,519,8,38,1,39,5,39,522,8,39,10,
		39,12,39,525,9,39,1,39,1,39,1,39,1,39,3,39,531,8,39,1,39,3,39,534,8,39,
		1,39,3,39,537,8,39,1,39,1,39,5,39,541,8,39,10,39,12,39,544,9,39,1,39,1,
		39,3,39,548,8,39,1,40,1,40,1,40,5,40,553,8,40,10,40,12,40,556,9,40,1,40,
		1,40,1,41,1,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,5,43,
		572,8,43,10,43,12,43,575,9,43,1,43,1,43,1,44,1,44,1,44,1,44,5,44,583,8,
		44,10,44,12,44,586,9,44,1,44,1,44,1,45,1,45,1,45,1,45,1,45,1,45,1,46,1,
		46,1,46,1,46,3,46,600,8,46,1,47,1,47,3,47,604,8,47,1,47,1,47,1,47,1,48,
		1,48,1,48,1,49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,
		1,51,1,51,1,51,5,51,627,8,51,10,51,12,51,630,9,51,3,51,632,8,51,1,51,1,
		51,1,52,1,52,1,52,1,52,1,53,3,53,641,8,53,1,53,1,53,1,53,1,53,1,53,3,53,
		648,8,53,1,53,1,53,1,53,3,53,653,8,53,1,54,3,54,656,8,54,1,54,1,54,3,54,
		660,8,54,1,55,1,55,1,55,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,57,1,58,1,
		58,1,58,1,59,1,59,1,59,1,59,1,59,5,59,681,8,59,10,59,12,59,684,9,59,1,
		59,1,59,1,59,1,60,5,60,690,8,60,10,60,12,60,693,9,60,1,60,1,60,1,61,1,
		61,1,61,1,61,1,61,5,61,702,8,61,10,61,12,61,705,9,61,1,61,1,61,1,61,3,
		61,710,8,61,1,61,1,61,1,62,1,62,1,62,1,63,1,63,1,63,1,63,1,63,1,63,3,63,
		723,8,63,1,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,1,66,1,66,1,66,1,
		66,1,66,1,66,1,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,
		68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,69,1,69,1,69,1,69,5,69,763,8,69,
		10,69,12,69,766,9,69,1,69,3,69,769,8,69,1,69,1,69,1,70,1,70,1,70,1,70,
		1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
		1,72,1,72,1,72,1,72,3,72,795,8,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
		72,1,72,1,72,3,72,807,8,72,1,72,1,72,3,72,811,8,72,1,72,1,72,3,72,815,
		8,72,1,72,1,72,3,72,819,8,72,1,72,1,72,3,72,823,8,72,1,72,1,72,3,72,827,
		8,72,1,72,1,72,3,72,831,8,72,1,72,1,72,3,72,835,8,72,1,72,1,72,1,72,4,
		72,840,8,72,11,72,12,72,841,1,72,1,72,1,72,1,72,1,72,4,72,849,8,72,11,
		72,12,72,850,1,72,1,72,1,72,1,72,1,72,4,72,858,8,72,11,72,12,72,859,1,
		72,1,72,1,72,3,72,865,8,72,1,73,3,73,868,8,73,1,73,1,73,1,74,1,74,1,74,
		1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
		1,74,1,74,1,74,1,74,1,74,3,74,894,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
		74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
		74,1,74,1,74,3,74,919,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,
		929,8,74,1,74,1,74,1,74,4,74,934,8,74,11,74,12,74,935,5,74,938,8,74,10,
		74,12,74,941,9,74,1,75,1,75,3,75,945,8,75,1,76,1,76,1,76,1,76,5,76,951,
		8,76,10,76,12,76,954,9,76,1,76,1,76,1,77,1,77,1,77,1,77,5,77,962,8,77,
		10,77,12,77,965,9,77,1,77,1,77,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,
		1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,3,78,
		990,8,78,1,79,1,79,3,79,994,8,79,1,80,1,80,1,80,1,80,3,80,1000,8,80,1,
		81,1,81,3,81,1004,8,81,1,82,1,82,1,82,5,82,1009,8,82,10,82,12,82,1012,
		9,82,1,83,1,83,1,84,1,84,3,84,1018,8,84,1,85,1,85,3,85,1022,8,85,1,86,
		1,86,3,86,1026,8,86,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1034,8,86,1,87,
		1,87,1,87,1,87,1,87,1,87,1,87,3,87,1043,8,87,1,88,1,88,1,88,1,88,1,88,
		1,88,1,88,1,88,1,88,3,88,1054,8,88,1,88,1,418,1,148,89,0,2,4,6,8,10,12,
		14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
		62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
		108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,
		144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,0,
		3,1,0,50,51,2,0,15,15,111,111,2,0,43,43,46,46,1174,0,178,1,0,0,0,2,185,
		1,0,0,0,4,188,1,0,0,0,6,199,1,0,0,0,8,203,1,0,0,0,10,229,1,0,0,0,12,234,
		1,0,0,0,14,241,1,0,0,0,16,243,1,0,0,0,18,270,1,0,0,0,20,274,1,0,0,0,22,
		276,1,0,0,0,24,293,1,0,0,0,26,307,1,0,0,0,28,316,1,0,0,0,30,326,1,0,0,
		0,32,334,1,0,0,0,34,347,1,0,0,0,36,363,1,0,0,0,38,366,1,0,0,0,40,370,1,
		0,0,0,42,372,1,0,0,0,44,376,1,0,0,0,46,379,1,0,0,0,48,392,1,0,0,0,50,399,
		1,0,0,0,52,404,1,0,0,0,54,406,1,0,0,0,56,409,1,0,0,0,58,412,1,0,0,0,60,
		424,1,0,0,0,62,438,1,0,0,0,64,453,1,0,0,0,66,465,1,0,0,0,68,468,1,0,0,
		0,70,471,1,0,0,0,72,490,1,0,0,0,74,495,1,0,0,0,76,518,1,0,0,0,78,523,1,
		0,0,0,80,549,1,0,0,0,82,559,1,0,0,0,84,561,1,0,0,0,86,564,1,0,0,0,88,578,
		1,0,0,0,90,589,1,0,0,0,92,595,1,0,0,0,94,603,1,0,0,0,96,608,1,0,0,0,98,
		611,1,0,0,0,100,615,1,0,0,0,102,619,1,0,0,0,104,635,1,0,0,0,106,652,1,
		0,0,0,108,655,1,0,0,0,110,661,1,0,0,0,112,664,1,0,0,0,114,668,1,0,0,0,
		116,672,1,0,0,0,118,675,1,0,0,0,120,691,1,0,0,0,122,696,1,0,0,0,124,713,
		1,0,0,0,126,716,1,0,0,0,128,724,1,0,0,0,130,727,1,0,0,0,132,733,1,0,0,
		0,134,742,1,0,0,0,136,750,1,0,0,0,138,758,1,0,0,0,140,772,1,0,0,0,142,
		776,1,0,0,0,144,864,1,0,0,0,146,867,1,0,0,0,148,893,1,0,0,0,150,942,1,
		0,0,0,152,946,1,0,0,0,154,957,1,0,0,0,156,989,1,0,0,0,158,993,1,0,0,0,
		160,999,1,0,0,0,162,1003,1,0,0,0,164,1005,1,0,0,0,166,1013,1,0,0,0,168,
		1015,1,0,0,0,170,1019,1,0,0,0,172,1033,1,0,0,0,174,1042,1,0,0,0,176,1053,
		1,0,0,0,178,179,5,1,0,0,179,180,3,164,82,0,180,181,5,71,0,0,181,1,1,0,
		0,0,182,184,3,4,2,0,183,182,1,0,0,0,184,187,1,0,0,0,185,183,1,0,0,0,185,
		186,1,0,0,0,186,3,1,0,0,0,187,185,1,0,0,0,188,190,5,2,0,0,189,191,5,7,
		0,0,190,189,1,0,0,0,190,191,1,0,0,0,191,192,1,0,0,0,192,195,3,164,82,0,
		193,194,5,72,0,0,194,196,5,88,0,0,195,193,1,0,0,0,195,196,1,0,0,0,196,
		197,1,0,0,0,197,198,5,71,0,0,198,5,1,0,0,0,199,200,3,166,83,0,200,201,
		5,104,0,0,201,202,3,148,74,0,202,7,1,0,0,0,203,204,5,93,0,0,204,218,3,
		164,82,0,205,215,5,64,0,0,206,211,3,6,3,0,207,208,5,73,0,0,208,210,3,6,
		3,0,209,207,1,0,0,0,210,213,1,0,0,0,211,209,1,0,0,0,211,212,1,0,0,0,212,
		216,1,0,0,0,213,211,1,0,0,0,214,216,3,148,74,0,215,206,1,0,0,0,215,214,
		1,0,0,0,215,216,1,0,0,0,216,217,1,0,0,0,217,219,5,65,0,0,218,205,1,0,0,
		0,218,219,1,0,0,0,219,9,1,0,0,0,220,230,5,3,0,0,221,230,5,4,0,0,222,230,
		5,5,0,0,223,230,5,6,0,0,224,230,5,7,0,0,225,230,5,8,0,0,226,230,5,9,0,
		0,227,230,5,11,0,0,228,230,5,10,0,0,229,220,1,0,0,0,229,221,1,0,0,0,229,
		222,1,0,0,0,229,223,1,0,0,0,229,224,1,0,0,0,229,225,1,0,0,0,229,226,1,
		0,0,0,229,227,1,0,0,0,229,228,1,0,0,0,230,11,1,0,0,0,231,233,3,10,5,0,
		232,231,1,0,0,0,233,236,1,0,0,0,234,232,1,0,0,0,234,235,1,0,0,0,235,13,
		1,0,0,0,236,234,1,0,0,0,237,242,5,12,0,0,238,242,5,13,0,0,239,242,5,14,
		0,0,240,242,5,15,0,0,241,237,1,0,0,0,241,238,1,0,0,0,241,239,1,0,0,0,241,
		240,1,0,0,0,242,15,1,0,0,0,243,246,5,103,0,0,244,247,5,52,0,0,245,247,
		3,18,9,0,246,244,1,0,0,0,246,245,1,0,0,0,247,252,1,0,0,0,248,249,5,73,
		0,0,249,251,3,18,9,0,250,248,1,0,0,0,251,254,1,0,0,0,252,250,1,0,0,0,252,
		253,1,0,0,0,253,255,1,0,0,0,254,252,1,0,0,0,255,256,5,102,0,0,256,17,1,
		0,0,0,257,271,3,166,83,0,258,260,3,20,10,0,259,261,3,16,8,0,260,259,1,
		0,0,0,260,261,1,0,0,0,261,271,1,0,0,0,262,264,3,20,10,0,263,265,3,16,8,
		0,264,263,1,0,0,0,264,265,1,0,0,0,265,268,1,0,0,0,266,269,3,84,42,0,267,
		269,5,77,0,0,268,266,1,0,0,0,268,267,1,0,0,0,268,269,1,0,0,0,269,271,1,
		0,0,0,270,257,1,0,0,0,270,258,1,0,0,0,270,262,1,0,0,0,271,19,1,0,0,0,272,
		275,3,174,87,0,273,275,3,164,82,0,274,272,1,0,0,0,274,273,1,0,0,0,275,
		21,1,0,0,0,276,278,3,166,83,0,277,279,5,77,0,0,278,277,1,0,0,0,278,279,
		1,0,0,0,279,284,1,0,0,0,280,281,5,16,0,0,281,285,3,18,9,0,282,283,5,60,
		0,0,283,285,3,18,9,0,284,280,1,0,0,0,284,282,1,0,0,0,284,285,1,0,0,0,285,
		291,1,0,0,0,286,289,5,104,0,0,287,290,5,52,0,0,288,290,3,18,9,0,289,287,
		1,0,0,0,289,288,1,0,0,0,290,292,1,0,0,0,291,286,1,0,0,0,291,292,1,0,0,
		0,292,23,1,0,0,0,293,296,5,103,0,0,294,297,5,52,0,0,295,297,3,22,11,0,
		296,294,1,0,0,0,296,295,1,0,0,0,297,302,1,0,0,0,298,299,5,73,0,0,299,301,
		3,22,11,0,300,298,1,0,0,0,301,304,1,0,0,0,302,300,1,0,0,0,302,303,1,0,
		0,0,303,305,1,0,0,0,304,302,1,0,0,0,305,306,5,102,0,0,306,25,1,0,0,0,307,
		308,5,16,0,0,308,313,3,18,9,0,309,310,5,73,0,0,310,312,3,18,9,0,311,309,
		1,0,0,0,312,315,1,0,0,0,313,311,1,0,0,0,313,314,1,0,0,0,314,27,1,0,0,0,
		315,313,1,0,0,0,316,317,5,17,0,0,317,322,3,18,9,0,318,319,5,73,0,0,319,
		321,3,18,9,0,320,318,1,0,0,0,321,324,1,0,0,0,322,320,1,0,0,0,322,323,1,
		0,0,0,323,29,1,0,0,0,324,322,1,0,0,0,325,327,5,8,0,0,326,325,1,0,0,0,326,
		327,1,0,0,0,327,328,1,0,0,0,328,329,3,18,9,0,329,332,3,166,83,0,330,331,
		5,104,0,0,331,333,3,148,74,0,332,330,1,0,0,0,332,333,1,0,0,0,333,31,1,
		0,0,0,334,343,5,64,0,0,335,340,3,30,15,0,336,337,5,73,0,0,337,339,3,30,
		15,0,338,336,1,0,0,0,339,342,1,0,0,0,340,338,1,0,0,0,340,341,1,0,0,0,341,
		344,1,0,0,0,342,340,1,0,0,0,343,335,1,0,0,0,343,344,1,0,0,0,344,345,1,
		0,0,0,345,346,5,65,0,0,346,33,1,0,0,0,347,356,5,64,0,0,348,353,3,148,74,
		0,349,350,5,73,0,0,350,352,3,148,74,0,351,349,1,0,0,0,352,355,1,0,0,0,
		353,351,1,0,0,0,353,354,1,0,0,0,354,357,1,0,0,0,355,353,1,0,0,0,356,348,
		1,0,0,0,356,357,1,0,0,0,357,358,1,0,0,0,358,359,5,65,0,0,359,35,1,0,0,
		0,360,362,3,144,72,0,361,360,1,0,0,0,362,365,1,0,0,0,363,361,1,0,0,0,363,
		364,1,0,0,0,364,37,1,0,0,0,365,363,1,0,0,0,366,367,5,71,0,0,367,39,1,0,
		0,0,368,371,3,148,74,0,369,371,3,144,72,0,370,368,1,0,0,0,370,369,1,0,
		0,0,371,41,1,0,0,0,372,373,5,66,0,0,373,374,3,36,18,0,374,375,5,67,0,0,
		375,43,1,0,0,0,376,377,5,105,0,0,377,378,3,40,20,0,378,45,1,0,0,0,379,
		382,5,107,0,0,380,383,3,40,20,0,381,383,3,42,21,0,382,380,1,0,0,0,382,
		381,1,0,0,0,383,47,1,0,0,0,384,385,5,70,0,0,385,386,3,36,18,0,386,387,
		5,34,0,0,387,388,5,71,0,0,388,393,1,0,0,0,389,390,3,44,22,0,390,391,5,
		73,0,0,391,393,1,0,0,0,392,384,1,0,0,0,392,389,1,0,0,0,393,49,1,0,0,0,
		394,400,3,42,21,0,395,396,3,44,22,0,396,397,5,71,0,0,397,400,1,0,0,0,398,
		400,3,38,19,0,399,394,1,0,0,0,399,395,1,0,0,0,399,398,1,0,0,0,400,51,1,
		0,0,0,401,405,3,42,21,0,402,405,3,144,72,0,403,405,3,38,19,0,404,401,1,
		0,0,0,404,402,1,0,0,0,404,403,1,0,0,0,405,53,1,0,0,0,406,407,5,7,0,0,407,
		408,3,50,25,0,408,55,1,0,0,0,409,410,3,18,9,0,410,411,3,34,17,0,411,57,
		1,0,0,0,412,413,5,70,0,0,413,418,3,56,28,0,414,415,5,73,0,0,415,417,3,
		56,28,0,416,414,1,0,0,0,417,420,1,0,0,0,418,419,1,0,0,0,418,416,1,0,0,
		0,419,59,1,0,0,0,420,418,1,0,0,0,421,423,3,8,4,0,422,421,1,0,0,0,423,426,
		1,0,0,0,424,422,1,0,0,0,424,425,1,0,0,0,425,427,1,0,0,0,426,424,1,0,0,
		0,427,428,3,12,6,0,428,429,3,18,9,0,429,431,3,32,16,0,430,432,3,58,29,
		0,431,430,1,0,0,0,431,432,1,0,0,0,432,433,1,0,0,0,433,434,3,50,25,0,434,
		61,1,0,0,0,435,437,3,8,4,0,436,435,1,0,0,0,437,440,1,0,0,0,438,436,1,0,
		0,0,438,439,1,0,0,0,439,441,1,0,0,0,440,438,1,0,0,0,441,443,3,12,6,0,442,
		444,3,24,12,0,443,442,1,0,0,0,443,444,1,0,0,0,444,445,1,0,0,0,445,446,
		3,18,9,0,446,447,3,166,83,0,447,448,3,32,16,0,448,449,3,50,25,0,449,63,
		1,0,0,0,450,452,3,8,4,0,451,450,1,0,0,0,452,455,1,0,0,0,453,451,1,0,0,
		0,453,454,1,0,0,0,454,456,1,0,0,0,455,453,1,0,0,0,456,458,3,12,6,0,457,
		459,3,24,12,0,458,457,1,0,0,0,458,459,1,0,0,0,459,460,1,0,0,0,460,461,
		3,18,9,0,461,462,5,59,0,0,462,463,3,86,43,0,463,464,3,72,36,0,464,65,1,
		0,0,0,465,466,5,61,0,0,466,467,3,50,25,0,467,67,1,0,0,0,468,469,5,62,0,
		0,469,470,3,50,25,0,470,69,1,0,0,0,471,472,5,63,0,0,472,473,3,50,25,0,
		473,71,1,0,0,0,474,491,3,50,25,0,475,476,5,66,0,0,476,478,3,66,33,0,477,
		479,3,68,34,0,478,477,1,0,0,0,478,479,1,0,0,0,479,481,1,0,0,0,480,482,
		3,70,35,0,481,480,1,0,0,0,481,482,1,0,0,0,482,483,1,0,0,0,483,484,5,67,
		0,0,484,491,1,0,0,0,485,486,5,104,0,0,486,488,3,148,74,0,487,485,1,0,0,
		0,487,488,1,0,0,0,488,489,1,0,0,0,489,491,5,71,0,0,490,474,1,0,0,0,490,
		475,1,0,0,0,490,487,1,0,0,0,491,73,1,0,0,0,492,494,3,8,4,0,493,492,1,0,
		0,0,494,497,1,0,0,0,495,493,1,0,0,0,495,496,1,0,0,0,496,498,1,0,0,0,497,
		495,1,0,0,0,498,499,3,12,6,0,499,500,3,18,9,0,500,501,3,166,83,0,501,502,
		3,72,36,0,502,75,1,0,0,0,503,519,3,74,37,0,504,519,3,78,39,0,505,507,3,
		54,27,0,506,508,3,120,60,0,507,506,1,0,0,0,507,508,1,0,0,0,508,519,1,0,
		0,0,509,511,3,60,30,0,510,512,3,120,60,0,511,510,1,0,0,0,511,512,1,0,0,
		0,512,519,1,0,0,0,513,515,3,62,31,0,514,516,3,120,60,0,515,514,1,0,0,0,
		515,516,1,0,0,0,516,519,1,0,0,0,517,519,3,64,32,0,518,503,1,0,0,0,518,
		504,1,0,0,0,518,505,1,0,0,0,518,509,1,0,0,0,518,513,1,0,0,0,518,517,1,
		0,0,0,519,77,1,0,0,0,520,522,3,8,4,0,521,520,1,0,0,0,522,525,1,0,0,0,523,
		521,1,0,0,0,523,524,1,0,0,0,524,526,1,0,0,0,525,523,1,0,0,0,526,527,3,
		12,6,0,527,528,3,14,7,0,528,530,3,166,83,0,529,531,3,24,12,0,530,529,1,
		0,0,0,530,531,1,0,0,0,531,533,1,0,0,0,532,534,3,26,13,0,533,532,1,0,0,
		0,533,534,1,0,0,0,534,536,1,0,0,0,535,537,3,28,14,0,536,535,1,0,0,0,536,
		537,1,0,0,0,537,547,1,0,0,0,538,542,5,66,0,0,539,541,3,76,38,0,540,539,
		1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,0,542,543,1,0,0,0,543,545,1,0,0,
		0,544,542,1,0,0,0,545,548,5,67,0,0,546,548,5,71,0,0,547,538,1,0,0,0,547,
		546,1,0,0,0,548,79,1,0,0,0,549,550,3,0,0,0,550,554,3,2,1,0,551,553,3,78,
		39,0,552,551,1,0,0,0,553,556,1,0,0,0,554,552,1,0,0,0,554,555,1,0,0,0,555,
		557,1,0,0,0,556,554,1,0,0,0,557,558,5,0,0,1,558,81,1,0,0,0,559,560,7,0,
		0,0,560,83,1,0,0,0,561,562,5,68,0,0,562,563,5,69,0,0,563,85,1,0,0,0,564,
		565,5,68,0,0,565,566,3,18,9,0,566,573,3,166,83,0,567,568,5,73,0,0,568,
		569,3,18,9,0,569,570,3,166,83,0,570,572,1,0,0,0,571,567,1,0,0,0,572,575,
		1,0,0,0,573,571,1,0,0,0,573,574,1,0,0,0,574,576,1,0,0,0,575,573,1,0,0,
		0,576,577,5,69,0,0,577,87,1,0,0,0,578,579,5,68,0,0,579,584,3,148,74,0,
		580,581,5,73,0,0,581,583,3,148,74,0,582,580,1,0,0,0,583,586,1,0,0,0,584,
		582,1,0,0,0,584,585,1,0,0,0,585,587,1,0,0,0,586,584,1,0,0,0,587,588,5,
		69,0,0,588,89,1,0,0,0,589,590,5,64,0,0,590,591,3,18,9,0,591,592,5,70,0,
		0,592,593,3,148,74,0,593,594,5,65,0,0,594,91,1,0,0,0,595,596,3,18,9,0,
		596,599,3,166,83,0,597,598,5,104,0,0,598,600,3,148,74,0,599,597,1,0,0,
		0,599,600,1,0,0,0,600,93,1,0,0,0,601,604,3,156,78,0,602,604,3,158,79,0,
		603,601,1,0,0,0,603,602,1,0,0,0,603,604,1,0,0,0,604,605,1,0,0,0,605,606,
		5,104,0,0,606,607,3,148,74,0,607,95,1,0,0,0,608,609,3,166,83,0,609,610,
		3,34,17,0,610,97,1,0,0,0,611,612,5,20,0,0,612,613,3,18,9,0,613,614,3,34,
		17,0,614,99,1,0,0,0,615,616,5,20,0,0,616,617,3,18,9,0,617,618,3,88,44,
		0,618,101,1,0,0,0,619,620,5,20,0,0,620,621,3,18,9,0,621,622,3,84,42,0,
		622,631,5,66,0,0,623,628,3,148,74,0,624,625,5,73,0,0,625,627,3,148,74,
		0,626,624,1,0,0,0,627,630,1,0,0,0,628,626,1,0,0,0,628,629,1,0,0,0,629,
		632,1,0,0,0,630,628,1,0,0,0,631,623,1,0,0,0,631,632,1,0,0,0,632,633,1,
		0,0,0,633,634,5,67,0,0,634,103,1,0,0,0,635,636,3,166,83,0,636,637,5,70,
		0,0,637,638,5,115,0,0,638,105,1,0,0,0,639,641,3,104,52,0,640,639,1,0,0,
		0,640,641,1,0,0,0,641,642,1,0,0,0,642,643,3,18,9,0,643,644,5,70,0,0,644,
		645,3,166,83,0,645,653,1,0,0,0,646,648,3,104,52,0,647,646,1,0,0,0,647,
		648,1,0,0,0,648,649,1,0,0,0,649,650,3,154,77,0,650,651,3,46,23,0,651,653,
		1,0,0,0,652,640,1,0,0,0,652,647,1,0,0,0,653,107,1,0,0,0,654,656,5,21,0,
		0,655,654,1,0,0,0,655,656,1,0,0,0,656,657,1,0,0,0,657,659,5,18,0,0,658,
		660,3,148,74,0,659,658,1,0,0,0,659,660,1,0,0,0,660,109,1,0,0,0,661,662,
		5,19,0,0,662,663,3,148,74,0,663,111,1,0,0,0,664,665,5,23,0,0,665,666,3,
		166,83,0,666,667,5,71,0,0,667,113,1,0,0,0,668,669,5,24,0,0,669,670,3,166,
		83,0,670,671,5,71,0,0,671,115,1,0,0,0,672,673,5,36,0,0,673,674,3,52,26,
		0,674,117,1,0,0,0,675,676,5,36,0,0,676,677,5,64,0,0,677,682,3,92,46,0,
		678,679,5,73,0,0,679,681,3,92,46,0,680,678,1,0,0,0,681,684,1,0,0,0,682,
		680,1,0,0,0,682,683,1,0,0,0,683,685,1,0,0,0,684,682,1,0,0,0,685,686,5,
		65,0,0,686,687,3,52,26,0,687,119,1,0,0,0,688,690,3,122,61,0,689,688,1,
		0,0,0,690,693,1,0,0,0,691,689,1,0,0,0,691,692,1,0,0,0,692,694,1,0,0,0,
		693,691,1,0,0,0,694,695,3,124,62,0,695,121,1,0,0,0,696,709,5,37,0,0,697,
		698,5,64,0,0,698,703,3,18,9,0,699,700,5,73,0,0,700,702,3,18,9,0,701,699,
		1,0,0,0,702,705,1,0,0,0,703,701,1,0,0,0,703,704,1,0,0,0,704,706,1,0,0,
		0,705,703,1,0,0,0,706,707,3,166,83,0,707,708,5,65,0,0,708,710,1,0,0,0,
		709,697,1,0,0,0,709,710,1,0,0,0,710,711,1,0,0,0,711,712,3,52,26,0,712,
		123,1,0,0,0,713,714,5,38,0,0,714,715,3,52,26,0,715,125,1,0,0,0,716,717,
		5,25,0,0,717,718,5,64,0,0,718,719,3,148,74,0,719,720,5,65,0,0,720,722,
		3,52,26,0,721,723,3,128,64,0,722,721,1,0,0,0,722,723,1,0,0,0,723,127,1,
		0,0,0,724,725,5,26,0,0,725,726,3,52,26,0,726,129,1,0,0,0,727,728,5,30,
		0,0,728,729,5,64,0,0,729,730,3,148,74,0,730,731,5,65,0,0,731,732,3,52,
		26,0,732,131,1,0,0,0,733,734,5,27,0,0,734,735,5,64,0,0,735,736,3,144,72,
		0,736,737,3,148,74,0,737,738,5,71,0,0,738,739,3,148,74,0,739,740,5,65,
		0,0,740,741,3,52,26,0,741,133,1,0,0,0,742,743,5,28,0,0,743,744,5,64,0,
		0,744,745,3,166,83,0,745,746,5,70,0,0,746,747,3,148,74,0,747,748,5,65,
		0,0,748,749,3,52,26,0,749,135,1,0,0,0,750,751,5,29,0,0,751,752,3,52,26,
		0,752,753,5,30,0,0,753,754,5,64,0,0,754,755,3,148,74,0,755,756,5,65,0,
		0,756,757,5,71,0,0,757,137,1,0,0,0,758,759,5,31,0,0,759,760,3,154,77,0,
		760,764,5,66,0,0,761,763,3,140,70,0,762,761,1,0,0,0,763,766,1,0,0,0,764,
		762,1,0,0,0,764,765,1,0,0,0,765,768,1,0,0,0,766,764,1,0,0,0,767,769,3,
		142,71,0,768,767,1,0,0,0,768,769,1,0,0,0,769,770,1,0,0,0,770,771,5,67,
		0,0,771,139,1,0,0,0,772,773,5,32,0,0,773,774,3,154,77,0,774,775,3,48,24,
		0,775,141,1,0,0,0,776,777,5,33,0,0,777,778,3,48,24,0,778,143,1,0,0,0,779,
		780,3,92,46,0,780,781,5,71,0,0,781,865,1,0,0,0,782,783,3,148,74,0,783,
		784,3,94,47,0,784,785,5,71,0,0,785,865,1,0,0,0,786,787,3,154,77,0,787,
		788,5,104,0,0,788,789,3,154,77,0,789,865,1,0,0,0,790,791,3,148,74,0,791,
		792,5,72,0,0,792,794,3,166,83,0,793,795,3,34,17,0,794,793,1,0,0,0,794,
		795,1,0,0,0,795,865,1,0,0,0,796,797,3,108,54,0,797,798,5,71,0,0,798,865,
		1,0,0,0,799,800,3,110,55,0,800,801,5,71,0,0,801,865,1,0,0,0,802,865,3,
		112,56,0,803,865,3,114,57,0,804,806,3,116,58,0,805,807,3,120,60,0,806,
		805,1,0,0,0,806,807,1,0,0,0,807,865,1,0,0,0,808,810,3,118,59,0,809,811,
		3,120,60,0,810,809,1,0,0,0,810,811,1,0,0,0,811,865,1,0,0,0,812,814,3,126,
		63,0,813,815,3,120,60,0,814,813,1,0,0,0,814,815,1,0,0,0,815,865,1,0,0,
		0,816,818,3,130,65,0,817,819,3,120,60,0,818,817,1,0,0,0,818,819,1,0,0,
		0,819,865,1,0,0,0,820,822,3,136,68,0,821,823,3,120,60,0,822,821,1,0,0,
		0,822,823,1,0,0,0,823,865,1,0,0,0,824,826,3,132,66,0,825,827,3,120,60,
		0,826,825,1,0,0,0,826,827,1,0,0,0,827,865,1,0,0,0,828,830,3,134,67,0,829,
		831,3,120,60,0,830,829,1,0,0,0,830,831,1,0,0,0,831,865,1,0,0,0,832,834,
		3,138,69,0,833,835,3,120,60,0,834,833,1,0,0,0,834,835,1,0,0,0,835,865,
		1,0,0,0,836,839,3,148,74,0,837,838,5,110,0,0,838,840,3,106,53,0,839,837,
		1,0,0,0,840,841,1,0,0,0,841,839,1,0,0,0,841,842,1,0,0,0,842,843,1,0,0,
		0,843,844,5,71,0,0,844,865,1,0,0,0,845,848,3,148,74,0,846,847,5,109,0,
		0,847,849,3,148,74,0,848,846,1,0,0,0,849,850,1,0,0,0,850,848,1,0,0,0,850,
		851,1,0,0,0,851,852,1,0,0,0,852,853,5,71,0,0,853,865,1,0,0,0,854,857,3,
		148,74,0,855,856,5,108,0,0,856,858,3,148,74,0,857,855,1,0,0,0,858,859,
		1,0,0,0,859,857,1,0,0,0,859,860,1,0,0,0,860,861,1,0,0,0,861,862,5,71,0,
		0,862,865,1,0,0,0,863,865,5,71,0,0,864,779,1,0,0,0,864,782,1,0,0,0,864,
		786,1,0,0,0,864,790,1,0,0,0,864,796,1,0,0,0,864,799,1,0,0,0,864,802,1,
		0,0,0,864,803,1,0,0,0,864,804,1,0,0,0,864,808,1,0,0,0,864,812,1,0,0,0,
		864,816,1,0,0,0,864,820,1,0,0,0,864,824,1,0,0,0,864,828,1,0,0,0,864,832,
		1,0,0,0,864,836,1,0,0,0,864,845,1,0,0,0,864,854,1,0,0,0,864,863,1,0,0,
		0,865,145,1,0,0,0,866,868,3,18,9,0,867,866,1,0,0,0,867,868,1,0,0,0,868,
		869,1,0,0,0,869,870,3,148,74,0,870,147,1,0,0,0,871,872,6,74,-1,0,872,894,
		3,166,83,0,873,874,3,160,80,0,874,875,3,148,74,24,875,894,1,0,0,0,876,
		877,5,21,0,0,877,894,3,148,74,20,878,879,5,64,0,0,879,880,3,148,74,0,880,
		881,5,65,0,0,881,894,1,0,0,0,882,894,3,90,45,0,883,894,3,100,50,0,884,
		894,3,102,51,0,885,894,3,176,88,0,886,894,3,18,9,0,887,894,3,106,53,0,
		888,894,3,92,46,0,889,894,3,98,49,0,890,894,3,110,55,0,891,894,3,138,69,
		0,892,894,3,154,77,0,893,871,1,0,0,0,893,873,1,0,0,0,893,876,1,0,0,0,893,
		878,1,0,0,0,893,882,1,0,0,0,893,883,1,0,0,0,893,884,1,0,0,0,893,885,1,
		0,0,0,893,886,1,0,0,0,893,887,1,0,0,0,893,888,1,0,0,0,893,889,1,0,0,0,
		893,890,1,0,0,0,893,891,1,0,0,0,893,892,1,0,0,0,894,939,1,0,0,0,895,896,
		10,23,0,0,896,897,3,156,78,0,897,898,3,148,74,24,898,938,1,0,0,0,899,900,
		10,17,0,0,900,901,5,75,0,0,901,902,3,148,74,0,902,903,5,70,0,0,903,904,
		3,148,74,18,904,938,1,0,0,0,905,906,10,4,0,0,906,907,5,76,0,0,907,938,
		3,148,74,5,908,909,10,1,0,0,909,910,3,158,79,0,910,911,3,148,74,2,911,
		938,1,0,0,0,912,913,10,22,0,0,913,938,3,162,81,0,914,915,10,21,0,0,915,
		916,5,22,0,0,916,918,3,18,9,0,917,919,3,166,83,0,918,917,1,0,0,0,918,919,
		1,0,0,0,919,938,1,0,0,0,920,921,10,19,0,0,921,938,3,88,44,0,922,923,10,
		9,0,0,923,938,3,94,47,0,924,925,10,8,0,0,925,926,5,72,0,0,926,928,3,166,
		83,0,927,929,3,34,17,0,928,927,1,0,0,0,928,929,1,0,0,0,929,938,1,0,0,0,
		930,933,10,3,0,0,931,932,5,110,0,0,932,934,3,106,53,0,933,931,1,0,0,0,
		934,935,1,0,0,0,935,933,1,0,0,0,935,936,1,0,0,0,936,938,1,0,0,0,937,895,
		1,0,0,0,937,899,1,0,0,0,937,905,1,0,0,0,937,908,1,0,0,0,937,912,1,0,0,
		0,937,914,1,0,0,0,937,920,1,0,0,0,937,922,1,0,0,0,937,924,1,0,0,0,937,
		930,1,0,0,0,938,941,1,0,0,0,939,937,1,0,0,0,939,940,1,0,0,0,940,149,1,
		0,0,0,941,939,1,0,0,0,942,944,3,18,9,0,943,945,3,166,83,0,944,943,1,0,
		0,0,944,945,1,0,0,0,945,151,1,0,0,0,946,947,5,64,0,0,947,952,3,150,75,
		0,948,949,5,73,0,0,949,951,3,150,75,0,950,948,1,0,0,0,951,954,1,0,0,0,
		952,950,1,0,0,0,952,953,1,0,0,0,953,955,1,0,0,0,954,952,1,0,0,0,955,956,
		5,65,0,0,956,153,1,0,0,0,957,958,5,64,0,0,958,963,3,146,73,0,959,960,5,
		73,0,0,960,962,3,146,73,0,961,959,1,0,0,0,962,965,1,0,0,0,963,961,1,0,
		0,0,963,964,1,0,0,0,964,966,1,0,0,0,965,963,1,0,0,0,966,967,5,65,0,0,967,
		155,1,0,0,0,968,990,5,88,0,0,969,990,5,89,0,0,970,990,5,92,0,0,971,990,
		5,85,0,0,972,990,5,86,0,0,973,990,5,74,0,0,974,990,5,81,0,0,975,990,5,
		82,0,0,976,990,5,87,0,0,977,990,5,98,0,0,978,990,5,99,0,0,979,990,5,100,
		0,0,980,990,5,101,0,0,981,990,5,102,0,0,982,990,5,103,0,0,983,990,5,94,
		0,0,984,990,5,95,0,0,985,990,5,96,0,0,986,990,5,97,0,0,987,988,5,75,0,
		0,988,990,5,75,0,0,989,968,1,0,0,0,989,969,1,0,0,0,989,970,1,0,0,0,989,
		971,1,0,0,0,989,972,1,0,0,0,989,973,1,0,0,0,989,974,1,0,0,0,989,975,1,
		0,0,0,989,976,1,0,0,0,989,977,1,0,0,0,989,978,1,0,0,0,989,979,1,0,0,0,
		989,980,1,0,0,0,989,981,1,0,0,0,989,982,1,0,0,0,989,983,1,0,0,0,989,984,
		1,0,0,0,989,985,1,0,0,0,989,986,1,0,0,0,989,987,1,0,0,0,990,157,1,0,0,
		0,991,994,5,90,0,0,992,994,5,91,0,0,993,991,1,0,0,0,993,992,1,0,0,0,994,
		159,1,0,0,0,995,1000,5,91,0,0,996,1000,5,74,0,0,997,1000,5,83,0,0,998,
		1000,5,84,0,0,999,995,1,0,0,0,999,996,1,0,0,0,999,997,1,0,0,0,999,998,
		1,0,0,0,1000,161,1,0,0,0,1001,1004,5,83,0,0,1002,1004,5,84,0,0,1003,1001,
		1,0,0,0,1003,1002,1,0,0,0,1004,163,1,0,0,0,1005,1010,3,166,83,0,1006,1007,
		5,72,0,0,1007,1009,3,166,83,0,1008,1006,1,0,0,0,1009,1012,1,0,0,0,1010,
		1008,1,0,0,0,1010,1011,1,0,0,0,1011,165,1,0,0,0,1012,1010,1,0,0,0,1013,
		1014,7,1,0,0,1014,167,1,0,0,0,1015,1017,5,40,0,0,1016,1018,3,16,8,0,1017,
		1016,1,0,0,0,1017,1018,1,0,0,0,1018,169,1,0,0,0,1019,1021,5,41,0,0,1020,
		1022,3,16,8,0,1021,1020,1,0,0,0,1021,1022,1,0,0,0,1022,171,1,0,0,0,1023,
		1025,7,2,0,0,1024,1026,3,16,8,0,1025,1024,1,0,0,0,1025,1026,1,0,0,0,1026,
		1034,1,0,0,0,1027,1034,5,44,0,0,1028,1034,5,45,0,0,1029,1034,5,46,0,0,
		1030,1034,5,47,0,0,1031,1034,5,48,0,0,1032,1034,5,49,0,0,1033,1023,1,0,
		0,0,1033,1027,1,0,0,0,1033,1028,1,0,0,0,1033,1029,1,0,0,0,1033,1030,1,
		0,0,0,1033,1031,1,0,0,0,1033,1032,1,0,0,0,1034,173,1,0,0,0,1035,1043,5,
		39,0,0,1036,1043,3,168,84,0,1037,1043,3,170,85,0,1038,1043,3,172,86,0,
		1039,1043,5,42,0,0,1040,1043,5,14,0,0,1041,1043,5,50,0,0,1042,1035,1,0,
		0,0,1042,1036,1,0,0,0,1042,1037,1,0,0,0,1042,1038,1,0,0,0,1042,1039,1,
		0,0,0,1042,1040,1,0,0,0,1042,1041,1,0,0,0,1043,175,1,0,0,0,1044,1054,5,
		59,0,0,1045,1054,5,60,0,0,1046,1054,5,52,0,0,1047,1054,5,57,0,0,1048,1054,
		5,58,0,0,1049,1054,5,53,0,0,1050,1054,5,54,0,0,1051,1054,5,55,0,0,1052,
		1054,5,56,0,0,1053,1044,1,0,0,0,1053,1045,1,0,0,0,1053,1046,1,0,0,0,1053,
		1047,1,0,0,0,1053,1048,1,0,0,0,1053,1049,1,0,0,0,1053,1050,1,0,0,0,1053,
		1051,1,0,0,0,1053,1052,1,0,0,0,1054,177,1,0,0,0,111,185,190,195,211,215,
		218,229,234,241,246,252,260,264,268,270,274,278,284,289,291,296,302,313,
		322,326,332,340,343,353,356,363,370,382,392,399,404,418,424,431,438,443,
		453,458,478,481,487,490,495,507,511,515,518,523,530,533,536,542,547,554,
		573,584,599,603,628,631,640,647,652,655,659,682,691,703,709,722,764,768,
		794,806,810,814,818,822,826,830,834,841,850,859,864,867,893,918,928,935,
		937,939,944,952,963,989,993,999,1003,1010,1017,1021,1025,1033,1042,1053
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace KScr.Antlr
